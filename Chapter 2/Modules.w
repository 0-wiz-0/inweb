[Modules::] Modules.

To search for included modules, and track dependencies between them.

@h Creation.
Each web of source material discovered by Inweb is given one of the following.
Ordinarily these are found only when reading in a web for weaving, tangling
and so on: in the vast majority of Inweb runs, all modules will have the
"module origin marker" |READING_WEB_MOM|. But when Inweb is constructing a
makefile for a suite of tools, it can also discover multiple webs by other
means.

@e READING_WEB_MOM from 0
@e MAKEFILE_TOOL_MOM
@e MAKEFILE_MODULE_MOM

=
typedef struct module {
	struct pathname *module_location;
	struct text_stream *module_name;
	struct linked_list *dependencies; /* of |module|: which other modules does this need? */
	int origin_marker; /* one of the |*_MOM| values above */
	MEMORY_MANAGEMENT
} module;

@ =
module *Modules::new(text_stream *name, pathname *at, int m) {
	module *M = CREATE(module);
	M->module_location = at;
	M->module_name = Str::duplicate(name);
	M->dependencies = NEW_LINKED_LIST(module);
	M->origin_marker = m;
	return M;
}

@ In the Inweb documentation, "module" is used to refer to a sidekick web which
contains a suite of utility routines, or a major component of a program, but
which is not a program in its own right.

Internally, though, every web produces a |module| structure. The one for the
main web -- which can be tangled, and results in an actual program -- is
internally named |"(main)"|, a name which the user will never see.

=
module *Modules::create_main_module(web *W) {
	return Modules::new(I"(main)", W->path_to_web, READING_WEB_MOM);
}

@h Dependencies.
When web A imports module B, we will say that A is dependent on B. A web
can import multiple modules, so there can a list of dependencies. These are
needed when constructing makefiles, since the source code in B affects the
program generated by A.

=
void Modules::dependency(module *A, module *B) {
	if ((A == NULL) || (B == NULL)) internal_error("no module");
	ADD_TO_LINKED_LIST(B, module, A->dependencies);
}

@h Searching.
The following abstracts the idea of a place where modules might be found.
(At one time there was going to be a more elaborate search hierarchy.)

=
typedef struct module_search {
	struct pathname *path_to_search;
	MEMORY_MANAGEMENT
} module_search;

@ =
module_search *Modules::make_search_path(pathname *ext_path) {
	module_search *ms = CREATE(module_search);
	ms->path_to_search = ext_path;
	return ms;
}

@ When a web's contents page says to |import Blah|, how do we find the module
called |Blah| on disc? We try four possibilities in sequence:

=
pathname *Modules::find(web *W, module_search *ms, text_stream *name) {
	pathname *tries[4];
	tries[0] = W?(W->path_to_web):NULL;
	tries[1] = Pathnames::up(tries[0]);
	tries[2] = path_to_inweb;
	tries[3] = ms->path_to_search;
	int N = 4;
	for (int i=0; i<N; i++) {
		TEMPORARY_TEXT(T);
		WRITE_TO(T, "%S-module", name);
		pathname *P = Pathnames::from_text_relative(tries[i], T);
		if (Modules::exists(P)) @<Accept this directory as the module@>;
		DISCARD_TEXT(T);
	}
	return NULL;
}

@ When the module is found (if it is), a suitable module structure is made,
and a dependency created from the web's |(main)| module to this one.

@<Accept this directory as the module@> =
	module *M = Modules::new(name, P, READING_WEB_MOM);
	Modules::dependency(W->as_module, M);
	return P;

@ We accept that a plausibly-named directory is indeed the module being
sought if it contains a file called |Contents.w|: it's then certainly going
to be a web of some kind.

=
int Modules::exists(pathname *P) {
	filename *Contents = Filenames::in_folder(P, I"Contents.w");
	return TextFiles::exists(Contents);
}

@ Once loaded, wherever they came from, we sometimes need to look up a
module by name.

=
module *Modules::find_loaded_by_name(text_file_position *tfp, text_stream *name) {
	module *M;
	LOOP_OVER(M, module)
		if (Str::eq(name, M->module_name))
			return M;
	Errors::in_text_file("unknown module name", tfp);
	return NULL;
}
