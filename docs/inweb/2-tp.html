<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>2/lc</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../inweb/index.html">inweb</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../foundation-module/index.html">foundation-module</a></li>
<li><a href="../foundation-test/index.html">foundation-test</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '2/tp' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="index.html">inweb</a></li><li><a href="index.html#2">Chapter 2: Parsing a Web</a></li><li><b>The Parser</b></li></ul><p class="purpose">To work through the program read in, assigning each line its category, and noting down other useful information as we go.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Sequence of parsing</a></li><li><a href="#SP1_1_6">&#167;1.1.6. Categorisatiom</a></li><li><a href="#SP3">&#167;3. Version errors</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Sequence of parsing. </b>At this point, thw web has been read into memory. It's a linked list of
chapters, each of which is a linked list of sections, each of which must
be parsed in turn.
</p>

<p class="inwebparagraph">When we're done, we offer the support code for the web's programming language
a chance to do some further work, if it wants to. (This is how, for example,
function definitions are recognised in C programs.) There is no requirement
for it to do anything.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Parser::parse_web</span><span class="plain">(</span><span class="reserved">web</span><span class="plain"> *</span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">inweb_mode</span><span class="plain">) {</span>
        <span class="reserved">chapter</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">;</span>
        <span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="reserved">chapter</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-</span><span class="element">&gt;chapters</span><span class="plain">)</span>
            <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">, </span><span class="reserved">section</span><span class="plain">, </span><span class="identifier">C</span><span class="plain">-</span><span class="element">&gt;sections</span><span class="plain">)</span>
                &lt;<span class="cwebmacro">Parse a section</span> <span class="cwebmacronumber">1.1</span>&gt;<span class="plain">;</span>
        <span class="functiontext">Languages::further_parsing</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-</span><span class="element">&gt;main_language</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Parser::parse_web is used in 2/tr (<a href="2-tr.html#SP2">&#167;2</a>).</p>

<p class="inwebparagraph"><a id="SP1_1"></a><b>&#167;1.1.  </b>The task now is to parse those source lines, categorise them, and group them
further into a linked list of paragraphs. The basic method would be simple
enough, but is made more elaborate by supporting both version 1 and version 2
markup syntax, and trying to detect incorrect uses of one within the other.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse a section</span> <span class="cwebmacronumber">1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">NO_LCAT</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">before_bar</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">next_par_number</span><span class="plain"> = 1;</span>
        <span class="reserved">paragraph</span><span class="plain"> *</span><span class="identifier">current_paragraph</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">tag_list</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">, *</span><span class="identifier">PL</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">L</span><span class="plain">; </span><span class="identifier">PL</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">, </span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">) {</span>
            &lt;<span class="cwebmacro">Apply tag list, if any</span> <span class="cwebmacronumber">1.1.2</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Remove tag list, if any</span> <span class="cwebmacronumber">1.1.1</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Detect implied paragraph breaks</span> <span class="cwebmacronumber">1.1.5</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Determine category for this source line</span> <span class="cwebmacronumber">1.1.6</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">tag_list</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">In version 2 syntax, construe the comment under the heading as the purpose</span> <span class="cwebmacronumber">1.1.4</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">If the section as a whole is tagged, apply that tag to each paragraph in it</span> <span class="cwebmacronumber">1.1.3</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1">&#167;1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_1"></a><b>&#167;1.1.1.  </b>In versiom 2 syntax, the notation for tags was clarified. The tag list
for a paragraph is the run of <code class="display"><span class="extract">^"This"</span></code> and <code class="display"><span class="extract">^"That"</span></code> markers at the end of
the line introducing that paragraph. They can only occur, therefore, on a
line beginning with an <code class="display"><span class="extract">@</span></code>. We extract them into a string called <code class="display"><span class="extract">tag_list</span></code>.
(The reason we can't act on them straight away, which would make for simpler
code, is that they need to be applied to a paragraph structure which doesn't
yet exist &mdash; it will only exist when the line has been fully parsed.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Remove tag list, if any</span> <span class="cwebmacronumber">1.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::get_first_char</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">) == </span><span class="character">'@'</span><span class="plain">) {</span>
            <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
            <span class="reserved">while</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%c*?)( *%^\</span><span class="plain">"</span><span class="string">%c+?\</span><span class="plain">"</span><span class="string">)(%c*)"</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &lt; </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
                    <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"tags written ^\</span><span class="plain">"</span><span class="string">thus\</span><span class="plain">"</span><span class="string">"</span><span class="plain">, </span><span class="constant">V2_SYNTAX</span><span class="plain">);</span>
                <span class="functiontext">Str::clear</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">tag_list</span><span class="plain">, </span><span class="string">"%S"</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
                <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]); </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="string">" %S"</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[2]);</span>
            <span class="plain">}</span>
            <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_2"></a><b>&#167;1.1.2.  </b>And now it's later, and we can safely apply the tags. <code class="display"><span class="extract">current_paragraph</span></code>
now points to the para which was created by this line, not the one before.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Apply tag list, if any</span> <span class="cwebmacronumber">1.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">tag_list</span><span class="plain">, </span><span class="identifier">L</span><span class="string">" *%^\</span><span class="plain">"</span><span class="string">(%c+?)\</span><span class="plain">"</span><span class="string"> *(%c*)"</span><span class="plain">)) {</span>
            <span class="functiontext">Tags::add_by_name</span><span class="plain">(</span><span class="identifier">current_paragraph</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">tag_list</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
        <span class="plain">}</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="functiontext">Str::clear</span><span class="plain">(</span><span class="identifier">tag_list</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_3"></a><b>&#167;1.1.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">If the section as a whole is tagged, apply that tag to each paragraph in it</span> <span class="cwebmacronumber">1.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">paragraph</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;tag_with</span><span class="plain">)</span>
            <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">, </span><span class="reserved">paragraph</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;paragraphs</span><span class="plain">)</span>
                <span class="functiontext">Tags::add_to_paragraph</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;tag_with</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_4"></a><b>&#167;1.1.4.  </b>The "purpose" of a section is a brief note about what it's for. In version 1
syntax, this had to be explicitly declared with a <code class="display"><span class="extract">@Purpose:</span></code> command; in
version 2 it's much tidier.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">In version 2 syntax, construe the comment under the heading as the purpose</span> <span class="cwebmacronumber">1.1.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">) {</span>
            <span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">L</span><span class="plain">) &amp;&amp; (</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> == </span><span class="constant">CHAPTER_HEADING_LCAT</span><span class="plain">)) </span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">;</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_purpose</span><span class="plain"> = </span><span class="functiontext">Parser::extract_purpose</span><span class="plain">(</span><span class="identifier">I</span><span class="string">""</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">?</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">: </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::len</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_purpose</span><span class="plain">) &gt; 0) </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">PURPOSE_LCAT</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_5"></a><b>&#167;1.1.5.  </b>A new paragraph is implied when a macro definition begins in the middle of
what otherwise would be code, or when a paragraph and its code divider are
immediately adjacent on the same line.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Detect implied paragraph breaks</span> <span class="cwebmacronumber">1.1.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">PL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">PL</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> == </span><span class="constant">CODE_BODY_LCAT</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Str::get_first_char</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">) == </span><span class="character">'@'</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, 1) == </span><span class="character">'&lt;'</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"%c&lt;(%c+)@&gt; *= *"</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">)) {</span>
            &lt;<span class="cwebmacro">Insert an implied paragraph break</span> <span class="cwebmacronumber">1.1.5.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">PL</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"@ *= *"</span><span class="plain">))) {</span>
            <span class="functiontext">Str::clear</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">);</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"="</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &lt; </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
                <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"implied paragraph breaks"</span><span class="plain">, </span><span class="constant">V2_SYNTAX</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Insert an implied paragraph break</span> <span class="cwebmacronumber">1.1.5.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_5_1"></a><b>&#167;1.1.5.1.  </b>We handle implied paragraph dividers by inserting a paragraph marker and
reparsing from there.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Insert an implied paragraph break</span> <span class="cwebmacronumber">1.1.5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">NL</span><span class="plain"> = </span><span class="functiontext">Lines::new_source_line</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"@"</span><span class="plain">, &amp;(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;source</span><span class="plain">));</span>
        <span class="identifier">PL</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain"> = </span><span class="identifier">NL</span><span class="plain">;</span>
        <span class="identifier">NL</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain"> = </span><span class="identifier">PL</span><span class="plain">;</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="reserved">continue</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_5">&#167;1.1.5</a> (twice).</p>

<p class="inwebparagraph"><a id="SP1_1_6"></a><b>&#167;1.1.6. Categorisatiom. </b>This is where the work is really done. We have a source line: is it comment,
code, definition, what?
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Determine category for this source line</span> <span class="cwebmacronumber">1.1.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="identifier">comment_mode</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">COMMENT_BODY_LCAT</span><span class="plain">; </span>    <span class="comment">until set otherwise down below</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;owning_paragraph</span><span class="plain"> = </span><span class="identifier">current_paragraph</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;source.line_count</span><span class="plain"> == 0) </span>&lt;<span class="cwebmacro">Parse the line as a probable chapter heading</span> <span class="cwebmacronumber">1.1.6.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;source.line_count</span><span class="plain"> &lt;= 1) </span>&lt;<span class="cwebmacro">Parse the line as a probable section heading</span> <span class="cwebmacronumber">1.1.6.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Parse the line as a possible Inweb command</span> <span class="cwebmacronumber">1.1.6.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Parse the line as a possible paragraph macro definition</span> <span class="cwebmacronumber">1.1.6.4</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::get_first_char</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">) == </span><span class="character">'='</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &lt; </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
                <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"column-1 '=' as code divider"</span><span class="plain">, </span><span class="constant">V2_SYNTAX</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Parse the line as an equals structural marker</span> <span class="cwebmacronumber">1.1.6.6</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Str::get_first_char</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">) == </span><span class="character">'@'</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, 1) != </span><span class="character">'&lt;'</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> != </span><span class="constant">MACRO_DEFINITION_LCAT</span><span class="plain">))</span>
            &lt;<span class="cwebmacro">Parse the line as a structural marker</span> <span class="cwebmacronumber">1.1.6.5</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">comment_mode</span><span class="plain">) </span>&lt;<span class="cwebmacro">This is a line destined for commentary</span> <span class="cwebmacronumber">1.1.6.7</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">comment_mode</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">) </span>&lt;<span class="cwebmacro">This is a line destined for the verbatim code</span> <span class="cwebmacronumber">1.1.6.8</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_1"></a><b>&#167;1.1.6.1.  </b>This must be one of the inserted lines marking chapter headings; it doesn't
come literally from the source web.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the line as a probable chapter heading</span> <span class="cwebmacronumber">1.1.6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Chapter Heading"</span><span class="plain">)) {</span>
            <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">CHAPTER_HEADING_LCAT</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_2"></a><b>&#167;1.1.6.2.  </b>The top line of a section gives its title and range; in InC, it can
also give the namespace for its functions.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the line as a probable section heading</span> <span class="cwebmacronumber">1.1.6.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"%[(%C+)%] (%C+/%C+): (%c+)."</span><span class="plain">)) {</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_namespace</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_title</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[2]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[2]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">SECTION_HEADING_LCAT</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%C+/%C+): (%c+)."</span><span class="plain">)) {</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_title</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">SECTION_HEADING_LCAT</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"%[(%C+::)%] (%c+)."</span><span class="plain">)) {</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_namespace</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_title</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
            &lt;<span class="cwebmacro">Set the range to an automatic abbreviation of the relative pathname</span> <span class="cwebmacronumber">1.1.6.2.1</span>&gt;<span class="plain">;</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">SECTION_HEADING_LCAT</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%c+)."</span><span class="plain">)) {</span>
            <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_title</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            &lt;<span class="cwebmacro">Set the range to an automatic abbreviation of the relative pathname</span> <span class="cwebmacronumber">1.1.6.2.1</span>&gt;<span class="plain">;</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">SECTION_HEADING_LCAT</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_2_1"></a><b>&#167;1.1.6.2.1.  </b>If no range is supplied, we make one ourselves.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Set the range to an automatic abbreviation of the relative pathname</span> <span class="cwebmacronumber">1.1.6.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain"> = </span><span class="functiontext">Str::new</span><span class="plain">();</span>

        <span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_title</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">letters_from_each_word</span><span class="plain"> = 5;</span>
        <span class="reserved">do</span><span class="plain"> {</span>
            <span class="functiontext">Str::clear</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">, </span><span class="string">"%S/"</span><span class="plain">, </span><span class="identifier">C</span><span class="plain">-</span><span class="element">&gt;ch_range</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Make the tail using this many consonants from each word</span> <span class="cwebmacronumber">1.1.6.2.1.1</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (--</span><span class="identifier">letters_from_each_word</span><span class="plain"> == 0) </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">while</span><span class="plain"> (</span><span class="functiontext">Str::len</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">) &gt; 5);</span>

        &lt;<span class="cwebmacro">Terminate with disambiguating numbers in case of collisions</span> <span class="cwebmacronumber">1.1.6.2.1.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_2">&#167;1.1.6.2</a> (twice).</p>

<p class="inwebparagraph"><a id="SP1_1_6_2_1_1"></a><b>&#167;1.1.6.2.1.1.  </b>We collapse words to an initial letter plus consonants: thus "electricity"
would be "elctrcty", since we don't count "y" as a vowel here.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make the tail using this many consonants from each word</span> <span class="cwebmacronumber">1.1.6.2.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">sn</span><span class="plain"> = 0, </span><span class="identifier">sw</span><span class="plain"> = </span><span class="functiontext">Str::len</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">sn</span><span class="plain">) == </span><span class="constant">FOLDER_SEPARATOR</span><span class="plain">) </span><span class="identifier">sn</span><span class="plain">++;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">letters_from_current_word</span><span class="plain"> = 0;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">sn</span><span class="plain">)) &amp;&amp; (</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">sn</span><span class="plain">) != </span><span class="character">'.'</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">sn</span><span class="plain">) == </span><span class="character">' '</span><span class="plain">) </span><span class="identifier">letters_from_current_word</span><span class="plain"> = 0;</span>
            <span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">letters_from_current_word</span><span class="plain"> &lt; </span><span class="identifier">letters_from_each_word</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">sn</span><span class="plain">) != </span><span class="character">'-'</span><span class="plain">) {</span>
                        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">l</span><span class="plain"> = </span><span class="identifier">tolower</span><span class="plain">(</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">sn</span><span class="plain">));</span>
                        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">letters_from_current_word</span><span class="plain"> == 0) ||</span>
                            <span class="plain">((</span><span class="identifier">l</span><span class="plain"> != </span><span class="character">'a'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">l</span><span class="plain"> != </span><span class="character">'e'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">l</span><span class="plain"> != </span><span class="character">'i'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">l</span><span class="plain"> != </span><span class="character">'o'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">l</span><span class="plain"> != </span><span class="character">'u'</span><span class="plain">))) {</span>
                            <span class="functiontext">Str::put_at</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">, </span><span class="identifier">sw</span><span class="plain">++, </span><span class="identifier">l</span><span class="plain">); </span><span class="functiontext">Str::put_at</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">, </span><span class="identifier">sw</span><span class="plain">, 0);</span>
                            <span class="identifier">letters_from_current_word</span><span class="plain">++;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="identifier">sn</span><span class="plain">++;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_2_1">&#167;1.1.6.2.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_2_1_2"></a><b>&#167;1.1.6.2.1.2.  </b>We never want two sections to have the same range.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Terminate with disambiguating numbers in case of collisions</span> <span class="cwebmacronumber">1.1.6.2.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">original_range</span><span class="plain">);</span>
        <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">original_range</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">disnum</span><span class="plain"> = 0, </span><span class="identifier">collision</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">do</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">disnum</span><span class="plain">++ &gt; 0) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ldn</span><span class="plain"> = 4;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">disnum</span><span class="plain"> &gt;= 1000) </span><span class="identifier">ldn</span><span class="plain"> = 3;</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">disnum</span><span class="plain"> &gt;= 100) </span><span class="identifier">ldn</span><span class="plain"> = 2;</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">disnum</span><span class="plain"> &gt;= 10) </span><span class="identifier">ldn</span><span class="plain"> = 1;</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">ldn</span><span class="plain"> = 0;</span>
                <span class="functiontext">Str::clear</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">, </span><span class="string">"%S"</span><span class="plain">, </span><span class="identifier">original_range</span><span class="plain">);</span>
                <span class="functiontext">Str::truncate</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">, </span><span class="functiontext">Str::len</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">) - </span><span class="identifier">ldn</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">, </span><span class="string">"%d"</span><span class="plain">, </span><span class="identifier">disnum</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">collision</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="reserved">chapter</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">;</span>
            <span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S2</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="reserved">chapter</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-</span><span class="element">&gt;chapters</span><span class="plain">)</span>
                <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">S2</span><span class="plain">, </span><span class="reserved">section</span><span class="plain">, </span><span class="identifier">C</span><span class="plain">-</span><span class="element">&gt;sections</span><span class="plain">)</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">S2</span><span class="plain"> != </span><span class="identifier">S</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Str::eq</span><span class="plain">(</span><span class="identifier">S2</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;range</span><span class="plain">))) {</span>
                        <span class="identifier">collision</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                    <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">while</span><span class="plain"> (</span><span class="identifier">collision</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">original_range</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_2_1">&#167;1.1.6.2.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_3"></a><b>&#167;1.1.6.3.  </b>Version 1 syntax was cluttered up with a number of hardly-used markup
syntaxes called "commands", written in double squared brackets <code class="display"><span class="extract">[[Thus]]</span></code>.
In version 2, this notation is used only for figures.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the line as a possible Inweb command</span> <span class="cwebmacronumber">1.1.6.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"%[%[(%c+)%]%]"</span><span class="plain">)) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">full_command</span><span class="plain">);</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">);</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">full_command</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">COMMAND_LCAT</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%c+?): *(%c+)"</span><span class="plain">)) {</span>
                <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
                <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Page Break"</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt; </span><span class="constant">V1_SYNTAX</span><span class="plain">)</span>
                    <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"[[Page Break]]"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
                <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;command_code</span><span class="plain"> = </span><span class="constant">PAGEBREAK_CMD</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Grammar Index"</span><span class="plain">))</span>
                <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;command_code</span><span class="plain"> = </span><span class="constant">GRAMMAR_INDEX_CMD</span><span class="plain">;</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Tag"</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt; </span><span class="constant">V1_SYNTAX</span><span class="plain">)</span>
                    <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"[[Tag...]]"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
                <span class="functiontext">Tags::add_by_name</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;owning_paragraph</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">);</span>
                <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;command_code</span><span class="plain"> = </span><span class="constant">TAG_CMD</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Figure"</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt; </span><span class="constant">V1_SYNTAX</span><span class="plain">)</span>
                    <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"[[Figure...]]"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
                <span class="functiontext">Tags::add_by_name</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;owning_paragraph</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"Figures"</span><span class="plain">);</span>
                <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;command_code</span><span class="plain"> = </span><span class="constant">FIGURE_CMD</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">) {</span>
                    <span class="functiontext">Tags::add_by_name</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;owning_paragraph</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"Figures"</span><span class="plain">);</span>
                    <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;command_code</span><span class="plain"> = </span><span class="constant">FIGURE_CMD</span><span class="plain">;</span>
                    <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="identifier">full_command</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"unknown [[command]]"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">full_command</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_4"></a><b>&#167;1.1.6.4.  </b>Some paragraphs define angle-bracketed macros, and those need special
handling. We'll call these "paragraph macros".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the line as a possible paragraph macro definition</span> <span class="cwebmacronumber">1.1.6.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Str::get_first_char</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">) == </span><span class="character">'@'</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Str::get_at</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, 1) == </span><span class="character">'&lt;'</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"%c&lt;(%c+)@&gt; *= *"</span><span class="plain">))) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">para_macro_name</span><span class="plain">);</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">para_macro_name</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">MACRO_DEFINITION_LCAT</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">current_paragraph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
                <span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"&lt;...&gt; definition begins outside of a paragraph"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="functiontext">Macros::create</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">current_paragraph</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="identifier">para_macro_name</span><span class="plain">);</span>
            <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">CODE_BODY_LCAT</span><span class="plain">; </span>    <span class="comment">code follows on subsequent lines</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">para_macro_name</span><span class="plain">);</span>
            <span class="reserved">continue</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5"></a><b>&#167;1.1.6.5.  </b>A structural marker is introduced by an <code class="display"><span class="extract">@</span></code> in column 1, and is a structural
division in the current section.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the line as a structural marker</span> <span class="cwebmacronumber">1.1.6.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">);</span>
        <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">);</span>
        <span class="functiontext">Str::delete_first_character</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">); </span>    <span class="comment">i.e., strip the at-sign from the front</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">);</span>
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%C*) *(%c*?)"</span><span class="plain">)) {</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Deal with a structural marker</span> <span class="cwebmacronumber">1.1.6.5.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">);</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="reserved">continue</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_6"></a><b>&#167;1.1.6.6.  </b>An equals sign in column 1 is also a structural marker:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the line as an equals structural marker</span> <span class="cwebmacronumber">1.1.6.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">BEGIN_CODE_LCAT</span><span class="plain">;</span>
        <span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">CODE_BODY_LCAT</span><span class="plain">;</span>
        <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"= *(%c+) *"</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">current_paragraph</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Str::eq</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0], </span><span class="identifier">I</span><span class="string">"(very early code)"</span><span class="plain">))) {</span>
                <span class="identifier">current_paragraph</span><span class="plain">-</span><span class="element">&gt;placed_very_early</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">current_paragraph</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Str::eq</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0], </span><span class="identifier">I</span><span class="string">"(early code)"</span><span class="plain">))) {</span>
                <span class="identifier">current_paragraph</span><span class="plain">-</span><span class="element">&gt;placed_early</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">current_paragraph</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Str::eq</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0], </span><span class="identifier">I</span><span class="string">"(not code)"</span><span class="plain">))) {</span>
                <span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">TEXT_EXTRACT_LCAT</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"unknown bracketed annotation"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"= *%C%c*"</span><span class="plain">)) {</span>
            <span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"unknown material after '='"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="reserved">continue</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1"></a><b>&#167;1.1.6.5.1.  </b>So here we have the possibilities which start with a column-1 <code class="display"><span class="extract">@</span></code> sign.
There appear to be hordes of these, but in fact most of them were removed
in Inweb syntax version 2: in modern syntax, only <code class="display"><span class="extract">@d</span></code>, <code class="display"><span class="extract">@e</span></code>, <code class="display"><span class="extract">@h</span></code>, their
long forms <code class="display"><span class="extract">@define</span></code>, <code class="display"><span class="extract">@enum</span></code> and <code class="display"><span class="extract">@heading</span></code>, and plain old <code class="display"><span class="extract">@</span></code> remain.
(But <code class="display"><span class="extract">@e</span></code> has a different meaning from in version 1.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Deal with a structural marker</span> <span class="cwebmacronumber">1.1.6.5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Purpose:"</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Deal with Purpose</span> <span class="cwebmacronumber">1.1.6.5.1.1</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Interface:"</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Deal with Interface</span> <span class="cwebmacronumber">1.1.6.5.1.2</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"Definitions:"</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Deal with Definitions</span> <span class="cwebmacronumber">1.1.6.5.1.3</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"----+"</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Deal with the bar</span> <span class="cwebmacronumber">1.1.6.5.1.4</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"c"</span><span class="plain">)) ||</span>
                <span class="plain">(</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"x"</span><span class="plain">)) ||</span>
                <span class="plain">((</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> == </span><span class="constant">V1_SYNTAX</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"e"</span><span class="plain">))))</span>
                    &lt;<span class="cwebmacro">Deal with the code and extract markers</span> <span class="cwebmacronumber">1.1.6.5.1.5</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"d"</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Deal with the define marker</span> <span class="cwebmacronumber">1.1.6.5.1.6</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"define"</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &lt; </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
                <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@define' for definitions (use '@d' instead)"</span><span class="plain">, </span><span class="constant">V2_SYNTAX</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Deal with the define marker</span> <span class="cwebmacronumber">1.1.6.5.1.6</span>&gt;<span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"enum"</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Deal with the enumeration marker</span> <span class="cwebmacronumber">1.1.6.5.1.7</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"e"</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">))</span>
            &lt;<span class="cwebmacro">Deal with the enumeration marker</span> <span class="cwebmacronumber">1.1.6.5.1.7</span>&gt;
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">weight</span><span class="plain"> = -1, </span><span class="identifier">new_page</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">""</span><span class="plain">)) </span><span class="identifier">weight</span><span class="plain"> = </span><span class="constant">ORDINARY_WEIGHT</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"h"</span><span class="plain">)) || (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"heading"</span><span class="plain">))) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &lt; </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
                    <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@h' or '@heading' for headings (use '@p' instead)"</span><span class="plain">, </span><span class="constant">V2_SYNTAX</span><span class="plain">);</span>
                <span class="identifier">weight</span><span class="plain"> = </span><span class="constant">SUBHEADING_WEIGHT</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"p"</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt; </span><span class="constant">V1_SYNTAX</span><span class="plain">)</span>
                    <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@p' for headings (use '@h' instead)"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
                <span class="identifier">weight</span><span class="plain"> = </span><span class="constant">SUBHEADING_WEIGHT</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"pp"</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt; </span><span class="constant">V1_SYNTAX</span><span class="plain">)</span>
                    <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@pp' for super-headings"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
                <span class="identifier">weight</span><span class="plain"> = </span><span class="constant">SUBHEADING_WEIGHT</span><span class="plain">; </span><span class="identifier">new_page</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">weight</span><span class="plain"> &gt;= 0) </span>&lt;<span class="cwebmacro">Begin a new paragraph of this weight</span> <span class="cwebmacronumber">1.1.6.5.1.8</span>&gt;
            <span class="reserved">else</span><span class="plain"> </span><span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"don't understand @command"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5">&#167;1.1.6.5</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_1"></a><b>&#167;1.1.6.5.1.1.  </b>In version 1 syntax there were some peculiar special headings above a divider
in the file made of hyphens, called "the bar". All of that has gone in V2.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Deal with Purpose</span> <span class="cwebmacronumber">1.1.6.5.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">before_bar</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">) </span><span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Purpose used after bar"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
            <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@Purpose'"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">PURPOSE_LCAT</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">);</span>
        <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_purpose</span><span class="plain"> = </span><span class="functiontext">Parser::extract_purpose</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;owning_section</span><span class="plain">, &amp;</span><span class="identifier">L</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_2"></a><b>&#167;1.1.6.5.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Deal with Interface</span> <span class="cwebmacronumber">1.1.6.5.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
            <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@Interface'"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">before_bar</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">) </span><span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Interface used after bar"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">INTERFACE_LCAT</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">XL</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">XL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">) &amp;&amp; (</span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;owning_section</span><span class="plain"> == </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;owning_section</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::get_first_char</span><span class="plain">(</span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">) == </span><span class="character">'@'</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">INTERFACE_BODY_LCAT</span><span class="plain">;</span>
            <span class="identifier">L</span><span class="plain"> = </span><span class="identifier">XL</span><span class="plain">;</span>
            <span class="identifier">XL</span><span class="plain"> = </span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_3"></a><b>&#167;1.1.6.5.1.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Deal with Definitions</span> <span class="cwebmacronumber">1.1.6.5.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
            <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@Definitions' headings"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">before_bar</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">) </span><span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Definitions used after bar"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">DEFINITIONS_LCAT</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">before_bar</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">next_par_number</span><span class="plain"> = 1;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_4"></a><b>&#167;1.1.6.5.1.4.  </b>An <code class="display"><span class="extract">@</span></code> sign in the first column, followed by a row of four or more dashes,
constitutes the optional division bar in a section.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Deal with the bar</span> <span class="cwebmacronumber">1.1.6.5.1.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt;= </span><span class="constant">V2_SYNTAX</span><span class="plain">)</span>
            <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"the bar '----...'"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">before_bar</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">) </span><span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"second bar in the same section"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">BAR_LCAT</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;barred</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">before_bar</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="identifier">next_par_number</span><span class="plain"> = 1;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_5"></a><b>&#167;1.1.6.5.1.5.  </b>In version 1, the division point where a paragraoh begins to go into
verbatim code was not marked with an equals sign, but with one of the three
commands <code class="display"><span class="extract">@c</span></code> ("code"), <code class="display"><span class="extract">@e</span></code> ("early code") and <code class="display"><span class="extract">@x</span></code> ("code-like extract").
These had identical behaviour except for whether or not to tangle what
follows:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Deal with the code and extract markers</span> <span class="cwebmacronumber">1.1.6.5.1.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt; </span><span class="constant">V1_SYNTAX</span><span class="plain">)</span>
            <span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="string">"'@c' and '@x'"</span><span class="plain">, </span><span class="constant">V1_SYNTAX</span><span class="plain">);</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">BEGIN_CODE_LCAT</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"e"</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">current_paragraph</span><span class="plain">))</span>
            <span class="identifier">current_paragraph</span><span class="plain">-</span><span class="element">&gt;placed_early</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">command_text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"x"</span><span class="plain">)) </span><span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">TEXT_EXTRACT_LCAT</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">CODE_BODY_LCAT</span><span class="plain">;</span>
        <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_6"></a><b>&#167;1.1.6.5.1.6.  </b>This is for <code class="display"><span class="extract">@d</span></code> and <code class="display"><span class="extract">@define</span></code>. Definitions are intended to translate to
C preprocessor macros, Inform 6 <code class="display"><span class="extract">Constant</span></code>s, and so on.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Deal with the define marker</span> <span class="cwebmacronumber">1.1.6.5.1.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">BEGIN_DEFINITION_LCAT</span><span class="plain">;</span>
        <span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">CONT_DEFINITION_LCAT</span><span class="plain">;</span>
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">remainder</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%C+) (%c+)"</span><span class="plain">)) {</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]); </span>    <span class="comment">name of term defined</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand2</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]); </span>    <span class="comment">Value</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">); </span>    <span class="comment">name of term defined</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand2</span><span class="plain"> = </span><span class="functiontext">Str::new</span><span class="plain">(); </span>    <span class="comment">no value given</span>
        <span class="plain">}</span>
        <span class="functiontext">Analyser::mark_reserved_word</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="constant">CONSTANT_COLOUR</span><span class="plain">);</span>
        <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a> (twice).</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_7"></a><b>&#167;1.1.6.5.1.7.  </b>This is for <code class="display"><span class="extract">@e</span></code> (in version 2) and <code class="display"><span class="extract">@enum</span></code>, which makes an automatically
enumerated sort of <code class="display"><span class="extract">@d</span></code>.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Deal with the enumeration marker</span> <span class="cwebmacronumber">1.1.6.5.1.7</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">BEGIN_DEFINITION_LCAT</span><span class="plain">;</span>
        <span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">); </span>    <span class="comment">name of term defined</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">before</span><span class="plain">);</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">after</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Languages::parse_comment</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_language</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">,</span>
            <span class="identifier">before</span><span class="plain">, </span><span class="identifier">after</span><span class="plain">)) {</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="identifier">before</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">before</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">after</span><span class="plain">);</span>
        <span class="functiontext">Str::trim_white_space</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%C+) from (%c+)"</span><span class="plain">)) {</span>
            <span class="identifier">from</span><span class="plain"> = </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1];</span>
            <span class="functiontext">Str::copy</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%C+) (%c+)"</span><span class="plain">)) {</span>
            <span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"enumeration constants can't supply a value"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand2</span><span class="plain"> = </span><span class="functiontext">Str::new</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">inweb_mode</span><span class="plain"> == </span><span class="constant">TANGLE_MODE</span><span class="plain">)</span>
            <span class="functiontext">Enumerations::define</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand2</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="functiontext">Analyser::mark_reserved_word</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain">, </span><span class="constant">CONSTANT_COLOUR</span><span class="plain">);</span>
        <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a> (twice).</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_8"></a><b>&#167;1.1.6.5.1.8.  </b>Here we handle paragraph breaks which may or may not be headings. In
version 1, <code class="display"><span class="extract">@p</span></code> was a heading, and <code class="display"><span class="extract">@pp</span></code> a grander heading, while plain <code class="display"><span class="extract">@</span></code>
is no heading at all. The use of "p" was a little confusing, and went back
to CWEB, which used the term "paragraph" differently from us: it was "p"
short for what CWEB called a "paragraph". We now use <code class="display"><span class="extract">@h</span></code> or equivalently
<code class="display"><span class="extract">@heading</span></code> for a heading.
</p>

<p class="inwebparagraph">The noteworthy thing here is the way we fool around with the text on the line
of the paragraph opening. This is one of the few cases where Inweb has
retained the stream-based style of CWEB, where escape characters can appear
anywhere in a line and line breaks are not significant. Thus
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">@h The chronology of French weaving. Auguste de Papillon (1734-56) soon</span>
</pre>

<p class="inwebparagraph">is split into two, so that the title of the paragraph is just "The chronology
of French weaving" and the remainder,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Auguste de Papillon (1734-56) soon</span>
</pre>

<p class="inwebparagraph">will be woven exactly as the succeeding lines will be.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ORDINARY_WEIGHT</span><span class="plain"> 0 </span>    <span class="comment">an ordinary paragraph has this "weight"</span>
    <span class="definitionkeyword">define</span> <span class="constant">SUBHEADING_WEIGHT</span><span class="plain"> 1 </span>    <span class="comment">a heading paragraph</span>
</pre>

<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Begin a new paragraph of this weight</span> <span class="cwebmacronumber">1.1.6.5.1.8</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">PARAGRAPH_START_LCAT</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">weight</span><span class="plain"> == </span><span class="constant">SUBHEADING_WEIGHT</span><span class="plain">) </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">HEADING_START_LCAT</span><span class="plain">;</span>
        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::new</span><span class="plain">(); </span>    <span class="comment">title</span>
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">weight</span><span class="plain"> == </span><span class="constant">SUBHEADING_WEIGHT</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">remainder</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%c+). (%c+)"</span><span class="plain">))) {</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand2</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[1]);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">weight</span><span class="plain"> == </span><span class="constant">SUBHEADING_WEIGHT</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">remainder</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%c+). *"</span><span class="plain">))) {</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand2</span><span class="plain"> = </span><span class="functiontext">Str::new</span><span class="plain">();</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::new</span><span class="plain">();</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand2</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">remainder</span><span class="plain">);</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Create a new paragraph, starting here, as new current paragraph</span> <span class="cwebmacronumber">1.1.6.5.1.8.2</span>&gt;<span class="plain">;</span>

        <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;owning_paragraph</span><span class="plain"> = </span><span class="identifier">current_paragraph</span><span class="plain">;</span>
        <span class="identifier">W</span><span class="plain">-</span><span class="element">&gt;no_paragraphs</span><span class="plain">++;</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_8_1"></a><b>&#167;1.1.6.5.1.8.1.  </b>So now it's time to create paragraph structures:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">paragraph</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">above_bar</span><span class="plain">; </span>    <span class="comment">placed above the dividing bar in its section (in Version 1 syntax)</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">placed_early</span><span class="plain">; </span>    <span class="comment">should appear early in the tangled code</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">placed_very_early</span><span class="plain">; </span>    <span class="comment">should appear very early in the tangled code</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">ornament</span><span class="plain">; </span>    <span class="comment">a "P" for a pilcrow or "S" for section-marker</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">paragraph_number</span><span class="plain">; </span>    <span class="comment">used in combination with the ornament</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">next_child_number</span><span class="plain">; </span>    <span class="comment">used when working out paragraph numbers</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">paragraph</span><span class="plain"> *</span><span class="identifier">parent_paragraph</span><span class="plain">; </span>    <span class="comment">ditto</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">weight</span><span class="plain">; </span>    <span class="comment">typographic prominence: one of the <code class="display"><span class="extract">*_WEIGHT</span></code> values</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">starts_on_new_page</span><span class="plain">; </span>    <span class="comment">relevant for weaving to TeX only, of course</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">para_macro</span><span class="plain"> *</span><span class="identifier">defines_macro</span><span class="plain">; </span>    <span class="comment">there can only be one</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">linked_list</span><span class="plain"> *</span><span class="identifier">functions</span><span class="plain">; </span>    <span class="comment">of <code class="display"><span class="extract">function</span></code>: those defined in this para</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">linked_list</span><span class="plain"> *</span><span class="identifier">structures</span><span class="plain">; </span>    <span class="comment">of <code class="display"><span class="extract">c_structure</span></code>: similarly</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">linked_list</span><span class="plain"> *</span><span class="identifier">taggings</span><span class="plain">; </span>    <span class="comment">of <code class="display"><span class="extract">paragraph_tagging</span></code></span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">first_line_in_paragraph</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">section</span><span class="plain"> *</span><span class="identifier">under_section</span><span class="plain">;</span>
        <span class="constant">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">paragraph</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure paragraph is accessed in 2/pm, 2/tgs, 2/pn, 3/tw, 3/tt, 4/cl, 4/is, 5/ptf, 5/tf, 5/hf and here.</p>

<p class="inwebparagraph"><a id="SP1_1_6_5_1_8_2"></a><b>&#167;1.1.6.5.1.8.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Create a new paragraph, starting here, as new current paragraph</span> <span class="cwebmacronumber">1.1.6.5.1.8.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">paragraph</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">paragraph</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> &gt; </span><span class="constant">V1_SYNTAX</span><span class="plain">) {</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;above_bar</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;placed_early</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;placed_very_early</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;above_bar</span><span class="plain"> = </span><span class="identifier">before_bar</span><span class="plain">;</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;placed_early</span><span class="plain"> = </span><span class="identifier">before_bar</span><span class="plain">;</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;placed_very_early</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;using_syntax</span><span class="plain"> == </span><span class="constant">V1_SYNTAX</span><span class="plain">) &amp;&amp; (</span><span class="identifier">before_bar</span><span class="plain">))</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;ornament</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"P"</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;ornament</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"S"</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;paragraph_number</span><span class="plain">, </span><span class="string">"%d"</span><span class="plain">, </span><span class="identifier">next_par_number</span><span class="plain">++);</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;parent_paragraph</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;next_child_number</span><span class="plain"> = 1;</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;starts_on_new_page</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;weight</span><span class="plain"> = </span><span class="identifier">weight</span><span class="plain">;</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;first_line_in_paragraph</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">;</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;defines_macro</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;functions</span><span class="plain"> = </span><span class="identifier">NEW_LINKED_LIST</span><span class="plain">(</span><span class="reserved">function</span><span class="plain">);</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;structures</span><span class="plain"> = </span><span class="identifier">NEW_LINKED_LIST</span><span class="plain">(</span><span class="reserved">c_structure</span><span class="plain">);</span>
        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;taggings</span><span class="plain"> = </span><span class="identifier">NEW_LINKED_LIST</span><span class="plain">(</span><span class="reserved">paragraph_tagging</span><span class="plain">);</span>

        <span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;under_section</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_paragraphs</span><span class="plain">++;</span>
        <span class="identifier">ADD_TO_LINKED_LIST</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">, </span><span class="reserved">paragraph</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;paragraphs</span><span class="plain">);</span>

        <span class="identifier">current_paragraph</span><span class="plain"> = </span><span class="identifier">P</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6_5_1_8">&#167;1.1.6.5.1.8</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_7"></a><b>&#167;1.1.6.7.  </b>Finally, we're down to either commentary or code.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">This is a line destined for commentary</span> <span class="cwebmacronumber">1.1.6.7</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext">Regexp::create_mr</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Regexp::match</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"&gt;&gt; (%c+)"</span><span class="plain">)) {</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">SOURCE_DISPLAY_LCAT</span><span class="plain">;</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text_operand</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">mr</span><span class="element">.exp</span><span class="plain">[0]);</span>
        <span class="plain">}</span>
        <span class="functiontext">Regexp::dispose_of</span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP1_1_6_8"></a><b>&#167;1.1.6.8.  </b>Note that in an <code class="display"><span class="extract">@d</span></code> definition, a blank line is treated as the end of the
definition. (This is unnecessary for C, and is a point of difference with
CWEB, but is needed for languages which don't allow multi-line definitions.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">This is a line destined for the verbatim code</span> <span class="cwebmacronumber">1.1.6.8</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> != </span><span class="constant">BEGIN_DEFINITION_LCAT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> != </span><span class="constant">COMMAND_LCAT</span><span class="plain">))</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="identifier">code_lcat_for_body</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> == </span><span class="constant">CONT_DEFINITION_LCAT</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Regexp::string_is_white_space</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">))) {</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">COMMENT_BODY_LCAT</span><span class="plain">;</span>
            <span class="identifier">L</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="identifier">code_lcat_for_body</span><span class="plain"> = </span><span class="constant">COMMENT_BODY_LCAT</span><span class="plain">;</span>
            <span class="identifier">comment_mode</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="functiontext">Languages::subcategorise_line</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;sect_language</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_1_6">&#167;1.1.6</a>.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>The purpose text occurs just below the heading. In version 1 it's cued with
a <code class="display"><span class="extract">@Purpose:</span></code> command; in version 2 it is unmarked. The following routine
is not elegant but handles the back end of both possibilities.
</p>


<pre class="display">
    <span class="reserved">text_stream</span><span class="plain"> *</span><span class="functiontext">Parser::extract_purpose</span><span class="plain">(</span><span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">prologue</span><span class="plain">, </span><span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">XL</span><span class="plain">, </span><span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">, </span><span class="reserved">source_line</span><span class="plain"> **</span><span class="identifier">adjust</span><span class="plain">) {</span>
        <span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Str::duplicate</span><span class="plain">(</span><span class="identifier">prologue</span><span class="plain">);</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">XL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">) &amp;&amp; (</span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;owning_section</span><span class="plain"> == </span><span class="identifier">S</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(((</span><span class="identifier">adjust</span><span class="plain">) &amp;&amp; (</span><span class="identifier">isalnum</span><span class="plain">(</span><span class="functiontext">Str::get_first_char</span><span class="plain">(</span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">)))) ||</span>
            <span class="plain">((!</span><span class="identifier">adjust</span><span class="plain">) &amp;&amp; (</span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> == </span><span class="constant">COMMENT_BODY_LCAT</span><span class="plain">)))) {</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">, </span><span class="string">" %S"</span><span class="plain">, </span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;text</span><span class="plain">);</span>
            <span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="constant">PURPOSE_BODY_LCAT</span><span class="plain">;</span>
            <span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;is_commentary</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">adjust</span><span class="plain">) *</span><span class="identifier">adjust</span><span class="plain"> = </span><span class="identifier">XL</span><span class="plain">;</span>
            <span class="identifier">XL</span><span class="plain"> = </span><span class="identifier">XL</span><span class="plain">-</span><span class="element">&gt;next_line</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext">Str::trim_white_space</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">P</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Parser::extract_purpose is used in <a href="#SP1_1_4">&#167;1.1.4</a>, <a href="#SP1_1_6_5_1_1">&#167;1.1.6.5.1.1</a>.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Version errors. </b>These are not fatal (why should they be?): Inweb carries on and allows the use
of the feature despite the version mismatch. They nevertheless count as errors
when it comes to Inweb's exit code, so they will halt a make.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Parser::wrong_version</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">using</span><span class="plain">, </span><span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">feature</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">need</span><span class="plain">) {</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">warning</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">warning</span><span class="plain">, </span><span class="string">"%s is a feature available only in version %d syntax (you're using version %d)"</span><span class="plain">,</span>
            <span class="identifier">feature</span><span class="plain">, </span><span class="identifier">need</span><span class="plain">, </span><span class="identifier">using</span><span class="plain">);</span>
        <span class="functiontext">Main::error_in_web</span><span class="plain">(</span><span class="identifier">warning</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">warning</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Parser::wrong_version is used in <a href="#SP1_1_1">&#167;1.1.1</a>, <a href="#SP1_1_5">&#167;1.1.5</a>, <a href="#SP1_1_6">&#167;1.1.6</a>, <a href="#SP1_1_6_3">&#167;1.1.6.3</a>, <a href="#SP1_1_6_5_1">&#167;1.1.6.5.1</a>, <a href="#SP1_1_6_5_1_1">&#167;1.1.6.5.1.1</a>, <a href="#SP1_1_6_5_1_2">&#167;1.1.6.5.1.2</a>, <a href="#SP1_1_6_5_1_3">&#167;1.1.6.5.1.3</a>, <a href="#SP1_1_6_5_1_4">&#167;1.1.6.5.1.4</a>, <a href="#SP1_1_6_5_1_5">&#167;1.1.6.5.1.5</a>, 3/tw (<a href="3-tw.html#SP1_3_3_1_2_1">&#167;1.3.3.1.2.1</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="2-lc.html">Back to 'Line Categories'</a></li><li><a href="2-pm.html">Continue with 'Paragraph Macros'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

