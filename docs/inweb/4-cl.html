<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>C-Like Languages</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Inweb Source</a></h1>
<ul>
<li><a href="../inweb/index.html">inweb</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../foundation-module/index.html">foundation-module</a></li>
<li><a href="../foundation-test/index.html">foundation-test</a></li>
</ul>
<h2>Example Webs</h2>
<ul>
<li><a href="../goldbach/index.html">goldbach</a></li>
<li><a href="../twinprimes/twinprimes.html">twinprimes</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of 'C-Like Languages' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Home</a></li><li><a href="index.html">inweb</a></li><li><a href="index.html#4">Chapter 4: Languages</a></li><li><b>C-Like Languages</b></li></ul><p class="purpose">To provide special features for the whole C family of languages.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. </a></li><li><a href="#SP2">&#167;2. Parsing</a></li><li><a href="#SP2_2">&#167;2.2. Structure dependency</a></li><li><a href="#SP3">&#167;3. Functions</a></li><li><a href="#SP4">&#167;4. Subcategorisation</a></li><li><a href="#SP5">&#167;5. Tangling extras</a></li><li><a href="#SP6">&#167;6. Tangling predeclarations</a></li><li><a href="#SP7">&#167;7. Overriding regular code weaving</a></li><li><a href="#SP8">&#167;8. Analysis</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>What makes a language C-like?
This does:
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::make_c_like<button class="popup" onclick="togglePopup('usagePopup180')">...<span class="popuptext" id="usagePopup180">Usage of <b>CLike::make_c_like</b>:<br>Programming Languages - <a href="4-pl.html#SP7_2">&#167;7.2</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">pl</span><span class="plain">) {</span>
        <span class="identifier">METHOD_ADD</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">, </span><span class="constant">PARSE_TYPES_PAR_MTID</span><span class="plain">, </span><span class="functiontext"><a href="#SP2">CLike::parse_types</a></span><span class="plain">);</span>
        <span class="identifier">METHOD_ADD</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">, </span><span class="constant">PARSE_FUNCTIONS_PAR_MTID</span><span class="plain">, </span><span class="functiontext"><a href="#SP3">CLike::parse_functions</a></span><span class="plain">);</span>
        <span class="identifier">METHOD_ADD</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">, </span><span class="constant">SUBCATEGORISE_LINE_PAR_MTID</span><span class="plain">, </span><span class="functiontext"><a href="#SP4">CLike::subcategorise_code</a></span><span class="plain">);</span>

        <span class="identifier">METHOD_ADD</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">, </span><span class="constant">ADDITIONAL_EARLY_MATTER_TAN_MTID</span><span class="plain">, </span><span class="functiontext"><a href="#SP5">CLike::additional_early_matter</a></span><span class="plain">);</span>
        <span class="identifier">METHOD_ADD</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">, </span><span class="constant">ADDITIONAL_PREDECLARATIONS_TAN_MTID</span><span class="plain">, </span><span class="functiontext"><a href="#SP6">CLike::additional_predeclarations</a></span><span class="plain">);</span>

        <span class="identifier">METHOD_ADD</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">, </span><span class="constant">EARLY_PREWEAVE_ANALYSIS_ANA_MTID</span><span class="plain">, </span><span class="functiontext"><a href="#SP8">CLike::analyse_code</a></span><span class="plain">);</span>
        <span class="identifier">METHOD_ADD</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">, </span><span class="constant">LATE_PREWEAVE_ANALYSIS_ANA_MTID</span><span class="plain">, </span><span class="functiontext"><a href="#SP9">CLike::post_analysis</a></span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Parsing. </b>After a web has been read in and then parsed, code supporting its language
is then called to do any further parsing it might want to. The code below
is run if the language is "C-like": regular C and InC both qualify.
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::parse_types<button class="popup" onclick="togglePopup('usagePopup181')">...<span class="popuptext" id="usagePopup181">Usage of <b>CLike::parse_types</b>:<br><a href="#SP1">&#167;1</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">web</span><span class="plain"> *</span><span class="identifier">W</span><span class="plain">) {</span>
        &lt;<span class="cwebmacro">Find every typedef struct in the tangle</span> <span class="cwebmacronumber">2.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Work out which structs contain which others</span> <span class="cwebmacronumber">2.2</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2_1"></a><b>&#167;2.1.  </b>We're going to assume that the C source code uses structures looking
something like this:
</p>

<pre class="display">
        <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="identifier">fruit</span><span class="plain"> {</span>
            <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">pip</span><span class="plain"> </span><span class="identifier">the_pips</span><span class="plain">[5];</span>
            <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">fruit</span><span class="plain"> *</span><span class="identifier">often_confused_with</span><span class="plain">;</span>
            <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">tree_species</span><span class="plain"> *</span><span class="identifier">grows_on</span><span class="plain">;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">typical_weight</span><span class="plain">;</span>
        <span class="plain">} </span><span class="identifier">fruit</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph">which adopts the traditional layout conventions of Kernighan and Ritchie.
The structure definitions in this Inweb web all take the required form,
of course, and provide many more examples.
</p>

<p class="inwebparagraph">Note that a <code class="display"><span class="extract">fruit</span></code> structure contains a <code class="display"><span class="extract">pip</span></code> structure (in fact, five of
them), but only contains pointers to <code class="display"><span class="extract">tree_species</span></code> structures and itself.
C requires therefore that the structure definition for <code class="display"><span class="extract">pip</span></code> must occur
earlier in the code than that for <code class="display"><span class="extract">fruit</span></code>. This is a nuisance, so Inweb
takes care of it automatically.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Find every typedef struct in the tangle</span> <span class="cwebmacronumber">2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">language_type</span><span class="plain"> *</span><span class="identifier">current_str</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">chapter</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">;</span>
        <span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">LOOP_WITHIN_TANGLE</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="functiontext"><a href="3-tt.html#SP4">Tangler::primary_target</a></span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"typedef struct (%i+) %c*{%c*"</span><span class="plain">)) {</span>
                <span class="identifier">current_str</span><span class="plain"> = </span><span class="functiontext"><a href="4-taf.html#SP2">Functions::new_struct</a></span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[0], </span><span class="identifier">L</span><span class="plain">);</span>
                <span class="functiontext"><a href="2-tgs.html#SP4">Tags::add_by_name</a></span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"Structures"</span><span class="plain">);</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get_first_char</a></span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">) == </span><span class="character">'}'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">current_str</span><span class="plain">)) {</span>
                <span class="identifier">current_str</span><span class="plain">-&gt;</span><span class="element">typedef_ends</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">;</span>
                <span class="identifier">current_str</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">current_str</span><span class="plain">) &amp;&amp; (</span><span class="identifier">current_str</span><span class="plain">-&gt;</span><span class="element">typedef_ends</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) {</span>
                &lt;<span class="cwebmacro">Work through a line in the structure definition</span> <span class="cwebmacronumber">2.1.1</span>&gt;<span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"typedef %c+"</span><span class="plain">)) &amp;&amp;</span>
                <span class="plain">(</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"%c+##%c+"</span><span class="plain">) == </span><span class="constant">FALSE</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">-&gt;</span><span class="element">placed_very_early</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">)</span>
                    <span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">category</span><span class="plain"> = </span><span class="constant">TYPEDEF_LCAT</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="functiontext"><a href="4-pm.html#SP9">Regexp::dispose_of</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2">&#167;2</a>.</p>

<p class="inwebparagraph"><a id="SP2_1_1"></a><b>&#167;2.1.1.  </b>At this point we're reading a line within the structure's definition; for
the sake of an illustrative example, let's suppose that line is:
</p>

<pre class="display">
        <span class="plain">unsigned long long int *val;</span>
</pre>

<p class="inwebparagraph">We need to extract the element name, <code class="display"><span class="extract">val</span></code>, and make a note of it.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Work through a line in the structure definition</span> <span class="cwebmacronumber">2.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">);</span>
        <span class="functiontext"><a href="4-sm.html#SP23">Str::trim_white_space</a></span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Remove C type modifiers from the front of p</span> <span class="cwebmacronumber">2.1.1.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">string_position</span><span class="plain"> </span><span class="identifier">pos</span><span class="plain"> = </span><span class="functiontext"><a href="4-sm.html#SP10">Str::start</a></span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) != </span><span class="character">'/'</span><span class="plain">) { /* </span><span class="identifier">a</span><span class="plain"> </span><span class="identifier">slash</span><span class="plain"> </span><span class="identifier">must</span><span class="plain"> </span><span class="identifier">introduce</span><span class="plain"> </span><span class="identifier">a</span><span class="plain"> </span><span class="identifier">comment</span><span class="plain"> </span><span class="identifier">here</span><span class="plain"> */</span>
            &lt;<span class="cwebmacro">Move pos past the type name</span> <span class="cwebmacronumber">2.1.1.2</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Move pos past any typographical type modifiers</span> <span class="cwebmacronumber">2.1.1.3</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-sm.html#SP11">Str::in_range</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">)) {</span>
                <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">elname</span><span class="plain">);</span>
                &lt;<span class="cwebmacro">Copy the element name into elname</span> <span class="cwebmacronumber">2.1.1.4</span>&gt;<span class="plain">;</span>
                <span class="functiontext"><a href="4-taf.html#SP4">Functions::new_element</a></span><span class="plain">(</span><span class="identifier">current_str</span><span class="plain">, </span><span class="identifier">elname</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">elname</span><span class="plain">);</span>
                <span class="functiontext"><a href="4-pm.html#SP9">Regexp::dispose_of</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_1">&#167;2.1</a>.</p>

<p class="inwebparagraph"><a id="SP2_1_1_1"></a><b>&#167;2.1.1.1.  </b>The following reduces <code class="display"><span class="extract">unsigned long long int *val;</span></code> to just <code class="display"><span class="extract">int *val;</span></code>.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Remove C type modifiers from the front of p</span> <span class="cwebmacronumber">2.1.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">modifier_patterns</span><span class="plain">[] = {</span>
            <span class="identifier">L</span><span class="string">"(struct )(%C%c*)"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(signed )(%C%c*)"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(unsigned )(%C%c*)"</span><span class="plain">,</span>
            <span class="identifier">L</span><span class="string">"(short )(%C%c*)"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(long )(%C%c*)"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(static )(%C%c*)"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain"> };</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">seek_modifiers</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">seek_modifiers</span><span class="plain">) {</span>
            <span class="identifier">seek_modifiers</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">; </span><span class="identifier">modifier_patterns</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]; </span><span class="identifier">i</span><span class="plain">++)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">modifier_patterns</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">])) {</span>
                    <span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[1]);</span>
                    <span class="identifier">seek_modifiers</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_1_1">&#167;2.1.1</a>.</p>

<p class="inwebparagraph"><a id="SP2_1_1_2"></a><b>&#167;2.1.1.2.  </b>At this point <code class="display"><span class="extract">p</span></code> has been reduced to <code class="display"><span class="extract">int *val;</span></code>, but the following moves
<code class="display"><span class="extract">pos</span></code> to point to the <code class="display"><span class="extract">*</span></code>:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Move pos past the type name</span> <span class="cwebmacronumber">2.1.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">while</span><span class="plain"> ((</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">)) &amp;&amp; (</span><span class="functiontext"><a href="4-chr.html#SP2">Characters::is_space_or_tab</a></span><span class="plain">(</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">)) == </span><span class="constant">FALSE</span><span class="plain">))</span>
            <span class="identifier">pos</span><span class="plain"> = </span><span class="functiontext"><a href="4-sm.html#SP11">Str::forward</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_1_1">&#167;2.1.1</a>.</p>

<p class="inwebparagraph"><a id="SP2_1_1_3"></a><b>&#167;2.1.1.3.  </b>And this moves it past the <code class="display"><span class="extract">*</span></code> to point to the <code class="display"><span class="extract">v</span></code> in <code class="display"><span class="extract">int *val;</span></code>:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Move pos past any typographical type modifiers</span> <span class="cwebmacronumber">2.1.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">while</span><span class="plain"> ((</span><span class="functiontext"><a href="4-chr.html#SP2">Characters::is_space_or_tab</a></span><span class="plain">(</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">))) || (</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="character">'*'</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="character">'('</span><span class="plain">) || (</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="character">')'</span><span class="plain">)) </span><span class="identifier">pos</span><span class="plain"> = </span><span class="functiontext"><a href="4-sm.html#SP11">Str::forward</a></span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_1_1">&#167;2.1.1</a>.</p>

<p class="inwebparagraph"><a id="SP2_1_1_4"></a><b>&#167;2.1.1.4.  </b>This then first copies the substring <code class="display"><span class="extract">val;</span></code> into <code class="display"><span class="extract">elname</span></code>, then cuts that
down to just the identifier characters at the front, i.e., to <code class="display"><span class="extract">val</span></code>.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Copy the element name into elname</span> <span class="cwebmacronumber">2.1.1.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext"><a href="4-sm.html#SP25">Str::substr</a></span><span class="plain">(</span><span class="identifier">elname</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">, </span><span class="functiontext"><a href="4-sm.html#SP10">Str::end</a></span><span class="plain">(</span><span class="identifier">p</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">elname</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%i+)%c*"</span><span class="plain">)) </span><span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">elname</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[0]);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_1_1">&#167;2.1.1</a>.</p>

<p class="inwebparagraph"><a id="SP2_2"></a><b>&#167;2.2. Structure dependency. </b>We say that S depends on T if <code class="display"><span class="extract">struct S</span></code> has an element whose type is
<code class="display"><span class="extract">struct T</span></code>. That matters because if so then <code class="display"><span class="extract">struct T</span></code> has to be defined
before <code class="display"><span class="extract">struct S</span></code> in the tangled output.
</p>

<p class="inwebparagraph">It's important to note that <code class="display"><span class="extract">struct S</span></code> merely having a member of type
<code class="display"><span class="extract">struct *T</span></code> does not create a dependency. In the code below, because <code class="display"><span class="extract">%i</span></code>
matches only identifier characters and <code class="display"><span class="extract">*</span></code> is not one of those, a line like
</p>

<pre class="display">
        <span class="plain">struct fruit *often_confused_with;</span>
</pre>

<p class="inwebparagraph">will not trip the switch here.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Work out which structs contain which others</span> <span class="cwebmacronumber">2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">language_type</span><span class="plain"> *</span><span class="identifier">current_str</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">current_str</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain">) {</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">current_str</span><span class="plain">-&gt;</span><span class="element">structure_header_at</span><span class="plain">;</span>
                <span class="plain">((</span><span class="identifier">L</span><span class="plain">) &amp;&amp; (</span><span class="identifier">L</span><span class="plain"> != </span><span class="identifier">current_str</span><span class="plain">-&gt;</span><span class="element">typedef_ends</span><span class="plain">));</span>
                <span class="identifier">L</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">next_line</span><span class="plain">) {</span>
                <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">" struct (%i+) %i%c*"</span><span class="plain">))</span>
                    &lt;<span class="cwebmacro">One structure appears to contain a copy of another one</span> <span class="cwebmacronumber">2.2.1</span>&gt;<span class="plain">;</span>
                <span class="functiontext"><a href="4-pm.html#SP9">Regexp::dispose_of</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2">&#167;2</a>.</p>

<p class="inwebparagraph"><a id="SP2_2_1"></a><b>&#167;2.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">One structure appears to contain a copy of another one</span> <span class="cwebmacronumber">2.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">used_structure</span><span class="plain"> = </span><span class="identifier">mr</span><span class="plain">.</span><span class="identifier">exp</span><span class="plain">[0];</span>
        <span class="reserved">language_type</span><span class="plain"> *</span><span class="identifier">str</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">str</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">language_types</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">str</span><span class="plain"> != </span><span class="identifier">current_str</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="functiontext"><a href="4-sm.html#SP18">Str::eq</a></span><span class="plain">(</span><span class="identifier">used_structure</span><span class="plain">, </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">structure_name</span><span class="plain">)))</span>
                <span class="identifier">ADD_TO_LINKED_LIST</span><span class="plain">(</span><span class="identifier">str</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain">, </span><span class="identifier">current_str</span><span class="plain">-&gt;</span><span class="element">incorporates</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_2">&#167;2.2</a>.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Functions. </b>This time, we will need to keep track of <code class="display"><span class="extract">#ifdef</span></code> and <code class="display"><span class="extract">#endif</span></code> pairs
in the source. This matters because we will want to predeclare functions;
but if functions are declared in conditional compilation, then their
predeclarations have to be made under the same conditions.
</p>

<p class="inwebparagraph">The following stack holds the current set of conditional compilations which the
source line being scanned lies within.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_CONDITIONAL_COMPILATION_STACK</span><span class="plain"> </span><span class="constant">8</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">cc_sp</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>
    <span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">cc_stack</span><span class="plain">[</span><span class="constant">MAX_CONDITIONAL_COMPILATION_STACK</span><span class="plain">];</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::parse_functions<button class="popup" onclick="togglePopup('usagePopup182')">...<span class="popuptext" id="usagePopup182">Usage of <b>CLike::parse_functions</b>:<br><a href="#SP1">&#167;1</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">web</span><span class="plain"> *</span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">cc_sp</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>
        <span class="reserved">chapter</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">;</span>
        <span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">LOOP_WITHIN_TANGLE</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="functiontext"><a href="3-tt.html#SP4">Tangler::primary_target</a></span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">category</span><span class="plain"> == </span><span class="constant">CODE_BODY_LCAT</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">category</span><span class="plain"> == </span><span class="constant">BEGIN_DEFINITION_LCAT</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">category</span><span class="plain"> == </span><span class="constant">CONT_DEFINITION_LCAT</span><span class="plain">)) {</span>
                &lt;<span class="cwebmacro">Look for conditional compilation on this line</span> <span class="cwebmacronumber">3.1</span>&gt;<span class="plain">;</span>
                &lt;<span class="cwebmacro">Look for a function definition on this line</span> <span class="cwebmacronumber">3.2</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cc_sp</span><span class="plain"> &gt; </span><span class="constant">0</span><span class="plain">)</span>
            <span class="functiontext"><a href="1-pc.html#SP8">Main::error_in_web</a></span><span class="plain">(</span><span class="identifier">I</span><span class="string">"program ended with conditional compilation open"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3_1"></a><b>&#167;3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Look for conditional compilation on this line</span> <span class="cwebmacronumber">3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">" *#ifn*def %c+"</span><span class="plain">)) ||</span>
            <span class="plain">(</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">" *#IFN*DEF %c+"</span><span class="plain">))) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cc_sp</span><span class="plain"> &gt;= </span><span class="constant">MAX_CONDITIONAL_COMPILATION_STACK</span><span class="plain">)</span>
                <span class="functiontext"><a href="1-pc.html#SP8">Main::error_in_web</a></span><span class="plain">(</span><span class="identifier">I</span><span class="string">"conditional compilation too deeply nested"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="identifier">cc_stack</span><span class="plain">[</span><span class="identifier">cc_sp</span><span class="plain">++] = </span><span class="identifier">L</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">" *#endif *"</span><span class="plain">)) ||</span>
            <span class="plain">(</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">" *#ENDIF *"</span><span class="plain">))) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cc_sp</span><span class="plain"> &lt;= </span><span class="constant">0</span><span class="plain">)</span>
                <span class="functiontext"><a href="1-pc.html#SP8">Main::error_in_web</a></span><span class="plain">(</span><span class="identifier">I</span><span class="string">"found #endif without #ifdef or #ifndef"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="identifier">cc_sp</span><span class="plain">--;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP3_2"></a><b>&#167;3.2.  </b>So, then, we recognise a C function as being a line which takes the form
</p>

<pre class="display">
        <span class="plain">type identifier(args...</span>
</pre>

<p class="inwebparagraph">where we parse <code class="display"><span class="extract">type</span></code> only minimally. In InC (only), the identifier can
contain namespace dividers written <code class="display"><span class="extract">::</span></code>. Function declarations, we will assume,
always begin on column 1 of their source files, and we expect them to take
modern ANSI C style, not the long-deprecated late 1970s C style.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Look for a function definition on this line</span> <span class="cwebmacronumber">3.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (!(</span><span class="functiontext"><a href="4-chr.html#SP2">Characters::is_space_or_tab</a></span><span class="plain">(</span><span class="functiontext"><a href="4-sm.html#SP13">Str::get_first_char</a></span><span class="plain">(</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">)))) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">qualifiers</span><span class="plain">);</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">modified</span><span class="plain">);</span>
            <span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">modified</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Parse past any type modifiers</span> <span class="cwebmacronumber">3.2.1</span>&gt;<span class="plain">;</span>
            <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">modified</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(%i+) (%**)(%i+)%((%c*)"</span><span class="plain">)) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">ftype</span><span class="plain">); </span><span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">ftype</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[0]);</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">asts</span><span class="plain">); </span><span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">asts</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[1]);</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">fname</span><span class="plain">); </span><span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">fname</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[2]);</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">); </span><span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[3]);</span>
                &lt;<span class="cwebmacro">A function definition was found</span> <span class="cwebmacronumber">3.2.2</span>&gt;<span class="plain">;</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">ftype</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">asts</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">fname</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">qualifiers</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">modified</span><span class="plain">);</span>
            <span class="functiontext"><a href="4-pm.html#SP9">Regexp::dispose_of</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP3_2_1"></a><b>&#167;3.2.1.  </b>C has a whole soup of reserved words applying to types, but most of them
can't apply to the return type of a function. We do, however, iterate so that
forms like <code class="display"><span class="extract">static long long int</span></code> will work.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse past any type modifiers</span> <span class="cwebmacronumber">3.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">modifier_patterns</span><span class="plain">[] = {</span>
            <span class="identifier">L</span><span class="string">"(signed )(%C%c*)"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(unsigned )(%C%c*)"</span><span class="plain">,</span>
            <span class="identifier">L</span><span class="string">"(short )(%C%c*)"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(long )(%C%c*)"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"(static )(%C%c*)"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain"> };</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">seek_modifiers</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">seek_modifiers</span><span class="plain">) {</span>
            <span class="identifier">seek_modifiers</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">; </span><span class="identifier">modifier_patterns</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]; </span><span class="identifier">i</span><span class="plain">++)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">modified</span><span class="plain">, </span><span class="identifier">modifier_patterns</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">])) {</span>
                    <span class="functiontext"><a href="4-sm.html#SP16">Str::concatenate</a></span><span class="plain">(</span><span class="identifier">qualifiers</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[0]);</span>
                    <span class="functiontext"><a href="4-sm.html#SP16">Str::copy</a></span><span class="plain">(</span><span class="identifier">modified</span><span class="plain">, </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[1]);</span>
                    <span class="identifier">seek_modifiers</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="functiontext"><a href="4-pm.html#SP9">Regexp::dispose_of</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3_2">&#167;3.2</a>.</p>

<p class="inwebparagraph"><a id="SP3_2_2"></a><b>&#167;3.2.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">A function definition was found</span> <span class="cwebmacronumber">3.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        &lt;<span class="cwebmacro">Soak up further arguments from continuation lines after the declaration</span> <span class="cwebmacronumber">3.2.2.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">language_function</span><span class="plain"> *</span><span class="identifier">fn</span><span class="plain"> = </span><span class="functiontext"><a href="4-taf.html#SP7">Functions::new_function</a></span><span class="plain">(</span><span class="identifier">fname</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_arguments</span><span class="plain"> = </span><span class="functiontext"><a href="4-sm.html#SP3">Str::duplicate</a></span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_type</span><span class="plain">, </span><span class="string">"%S%S %S"</span><span class="plain">, </span><span class="identifier">qualifiers</span><span class="plain">, </span><span class="identifier">ftype</span><span class="plain">, </span><span class="identifier">asts</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-sm.html#SP21">Str::eq_wide_string</a></span><span class="plain">(</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_name</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"isdigit"</span><span class="plain">)) </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">call_freely</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">no_conditionals</span><span class="plain"> = </span><span class="identifier">cc_sp</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">cc_sp</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">within_conditionals</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = </span><span class="identifier">cc_stack</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3_2">&#167;3.2</a>.</p>

<p class="inwebparagraph"><a id="SP3_2_2_1"></a><b>&#167;3.2.2.1.  </b>In some cases the function's declaration runs over several lines:
</p>

<pre class="display">
        <span class="reserved">void</span><span class="plain"> </span><span class="identifier">World::Subjects::make_adj_const_domain</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">,|</span>
            <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">nc</span><span class="plain">, </span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {|</span>
</pre>

<p class="inwebparagraph">Having read the first line, <code class="display"><span class="extract">arguments</span></code> would contain <code class="display"><span class="extract">inference_subject *infs,</span></code>
and would thus be incomplete. We continue across subsequent lines until we
reach an open brace <code class="display"><span class="extract">{</span></code>.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_ARG_LINES</span><span class="plain"> </span><span class="constant">32</span><span class="plain"> </span><span class="comment"> maximum number of lines over which a function's header can extend</span>
</pre>

<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Soak up further arguments from continuation lines after the declaration</span> <span class="cwebmacronumber">3.2.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">AL</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">arg_lc</span><span class="plain"> = </span><span class="constant">1</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">AL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">arg_lc</span><span class="plain"> &lt;= </span><span class="constant">MAX_ARG_LINES</span><span class="plain">) &amp;&amp; (</span><span class="functiontext"><a href="4-pm.html#SP4">Regexp::find_open_brace</a></span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">) == -1)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">AL</span><span class="plain">-&gt;</span><span class="element">next_line</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">err_mess</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">err_mess</span><span class="plain">, </span><span class="string">"Function '%S' has a malformed declaration"</span><span class="plain">, </span><span class="identifier">fname</span><span class="plain">);</span>
                <span class="functiontext"><a href="1-pc.html#SP8">Main::error_in_web</a></span><span class="plain">(</span><span class="identifier">err_mess</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">err_mess</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">AL</span><span class="plain"> = </span><span class="identifier">AL</span><span class="plain">-&gt;</span><span class="element">next_line</span><span class="plain">;</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">, </span><span class="string">" %S"</span><span class="plain">, </span><span class="identifier">AL</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">);</span>
            <span class="identifier">arg_lc</span><span class="plain">++;</span>
        <span class="plain">}</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP4">Regexp::find_open_brace</a></span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">n</span><span class="plain"> &gt;= </span><span class="constant">0</span><span class="plain">) </span><span class="functiontext"><a href="4-sm.html#SP15">Str::truncate</a></span><span class="plain">(</span><span class="identifier">arguments</span><span class="plain">, </span><span class="identifier">n</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3_2_2">&#167;3.2.2</a>.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Subcategorisation. </b>The following is called after the parser gives every line in the web a
category; we can, if we wish, change that for a more exotic one. We simply
look for a <code class="display"><span class="extract">#include</span></code> of one of the ANSI C standard libraries.
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::subcategorise_code<button class="popup" onclick="togglePopup('usagePopup183')">...<span class="popuptext" id="usagePopup183">Usage of <b>CLike::subcategorise_code</b>:<br><a href="#SP1">&#167;1</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain">) {</span>
        <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"#include &lt;(%C+)&gt;%c*"</span><span class="plain">)) {</span>
            <span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">library_file</span><span class="plain"> = </span><span class="identifier">mr</span><span class="plain">.</span><span class="element">exp</span><span class="plain">[0];</span>
            <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">ansi_libs</span><span class="plain">[] = {</span>
                <span class="identifier">L</span><span class="string">"assert.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"ctype.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"errno.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"float.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"limits.h"</span><span class="plain">,</span>
                <span class="identifier">L</span><span class="string">"locale.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"math.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"setjmp.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"signal.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"stdarg.h"</span><span class="plain">,</span>
                <span class="identifier">L</span><span class="string">"stddef.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"stdio.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"stdlib.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"string.h"</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"time.h"</span><span class="plain">,</span>
                <span class="identifier">NULL</span>
            <span class="plain">};</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">; </span><span class="identifier">ansi_libs</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]; </span><span class="identifier">j</span><span class="plain">++)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-sm.html#SP21">Str::eq_wide_string</a></span><span class="plain">(</span><span class="identifier">library_file</span><span class="plain">, </span><span class="identifier">ansi_libs</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]))</span>
                    <span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">category</span><span class="plain"> = </span><span class="constant">C_LIBRARY_INCLUDE_LCAT</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext"><a href="4-pm.html#SP9">Regexp::dispose_of</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Tangling extras. </b>"Additional early matter" is used for the inclusions of the ANSI library
files. We need to do that early, because otherwise types declared in them
(such as <code class="display"><span class="extract">FILE</span></code>) won't exist in time for the structure definitions we will
be tangling next.
</p>

<p class="inwebparagraph">It might seem reasonable to move all <code class="display"><span class="extract">#include</span></code> files up front this way,
not just the ANSI ones. But that would defeat any conditional compilation
around the inclusions; which Inform (for instance) needs in order to make
platform-specific details to handle directories without POSIX in Windows.
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::additional_early_matter<button class="popup" onclick="togglePopup('usagePopup184')">...<span class="popuptext" id="usagePopup184">Usage of <b>CLike::additional_early_matter</b>:<br><a href="#SP1">&#167;1</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">OUT</span><span class="plain">, </span><span class="reserved">web</span><span class="plain"> *</span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">tangle_target</span><span class="plain"> *</span><span class="identifier">target</span><span class="plain">) {</span>
        <span class="reserved">chapter</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">;</span>
        <span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">LOOP_WITHIN_TANGLE</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">target</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">category</span><span class="plain"> == </span><span class="constant">C_LIBRARY_INCLUDE_LCAT</span><span class="plain">) {</span>
                <span class="functiontext"><a href="2-tgs.html#SP7">Tags::open_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
                <span class="functiontext"><a href="3-tt.html#SP3">Tangler::tangle_code</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\n"</span><span class="plain">);</span>
                <span class="functiontext"><a href="2-tgs.html#SP7">Tags::close_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
            <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Tangling predeclarations. </b>This is where a language gets the chance to tangle predeclarations, early
on in the file. We use it first for the structures, and then the functions &mdash;
in that order since the function types likely involve the typedef names for the
structures.
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::additional_predeclarations<button class="popup" onclick="togglePopup('usagePopup185')">...<span class="popuptext" id="usagePopup185">Usage of <b>CLike::additional_predeclarations</b>:<br><a href="#SP1">&#167;1</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">text_stream</span><span class="plain"> *</span><span class="identifier">OUT</span><span class="plain">, </span><span class="reserved">web</span><span class="plain"> *</span><span class="identifier">W</span><span class="plain">) {</span>
        &lt;<span class="cwebmacro">Predeclare the structures in a well-founded order</span> <span class="cwebmacronumber">6.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Predeclare simple typedefs</span> <span class="cwebmacronumber">6.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Predeclare the functions</span> <span class="cwebmacronumber">6.4</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b>A "simple typedef" here means one that is aliasing something other than
a structure: for example <code class="display"><span class="extract">typedef unsigned int uint;</span></code> would be a simple typedef.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Predeclare simple typedefs</span> <span class="cwebmacronumber">6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">chapter</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">;</span>
        <span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">LOOP_WITHIN_TANGLE</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="functiontext"><a href="3-tt.html#SP4">Tangler::primary_target</a></span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">category</span><span class="plain"> == </span><span class="constant">TYPEDEF_LCAT</span><span class="plain">) {</span>
                <span class="functiontext"><a href="2-tgs.html#SP7">Tags::open_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
                <span class="functiontext"><a href="4-lm.html#SP19">LanguageMethods::tangle_code</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">main_language</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\n"</span><span class="plain">);</span>
                <span class="functiontext"><a href="2-tgs.html#SP7">Tags::close_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
            <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_2"></a><b>&#167;6.2.  </b>It's easy enough to make sure structures are tangled so that inner ones
precede outer, but we need to be careful to be terminating if the source
code we're given is not well founded because of an error by its programmer:
for example, that structure A contains B contains C contains A. We do this
with the <code class="display"><span class="extract">tangled</span></code> flag, which is <code class="display"><span class="extract">FALSE</span></code> if a structure hasn't been
started yet, <code class="display"><span class="extract">NOT_APPLICABLE</span></code> if it's in progress, and <code class="display"><span class="extract">TRUE</span></code> if it's
finished.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Predeclare the structures in a well-founded order</span> <span class="cwebmacronumber">6.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">language_type</span><span class="plain"> *</span><span class="identifier">str</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">str</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">language_types</span><span class="plain">)</span>
            <span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">tangled</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">str</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">language_types</span><span class="plain">)</span>
            <span class="functiontext"><a href="#SP6_3">CLike::tangle_structure</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">self</span><span class="plain">, </span><span class="identifier">str</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_3"></a><b>&#167;6.3.  </b>Using the following recursion, which is therefore terminating:
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::tangle_structure<button class="popup" onclick="togglePopup('usagePopup186')">...<span class="popuptext" id="usagePopup186">Usage of <b>CLike::tangle_structure</b>:<br><a href="#SP6_2">&#167;6.2</a></span></button></span><span class="plain">(</span><span class="constant">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain"> *</span><span class="identifier">str</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">tangled</span><span class="plain"> != </span><span class="constant">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">tangled</span><span class="plain"> = </span><span class="constant">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="reserved">language_type</span><span class="plain"> *</span><span class="identifier">embodied</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">embodied</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain">, </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">incorporates</span><span class="plain">)</span>
            <span class="functiontext"><a href="#SP6_3">CLike::tangle_structure</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">self</span><span class="plain">, </span><span class="identifier">embodied</span><span class="plain">);</span>
        <span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">tangled</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="functiontext"><a href="2-tgs.html#SP7">Tags::open_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">structure_header_at</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
        <span class="functiontext"><a href="4-lm.html#SP15">LanguageMethods::insert_line_marker</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">self</span><span class="plain">, </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">structure_header_at</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">source_line</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">structure_header_at</span><span class="plain">; </span><span class="identifier">L</span><span class="plain">; </span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">next_line</span><span class="plain">) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%S\n"</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">text</span><span class="plain">);</span>
            <span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">suppress_tangling</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">L</span><span class="plain"> == </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">typedef_ends</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext"><a href="2-tgs.html#SP7">Tags::close_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">structure_header_at</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6_4"></a><b>&#167;6.4.  </b>Functions are rather easier to deal with. In general, if a function was
defined within some number of nested <code class="display"><span class="extract">#ifdef</span></code> or <code class="display"><span class="extract">#ifndef</span></code> directives, then
we reproduce those around the predeclaration: except, as a special trick,
if the line contains a particular comment. For example:
</p>

<pre class="display">
        <span class="plain">#ifdef SOLARIS /* inweb: always predeclare */</span>
</pre>

<p class="inwebparagraph">That exempts any functions inside this condition from meeting the condition
in order to be predeclared. It's a trick used in the foundation module just
a couple of times: the idea is that although a definition of the functions
is given which only works under SOLARIS, an external piece of code will
provide alternative function definitions which would work without SOLARIS.
The functions therefore need predeclaration regardless, because they will
exist either way.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Predeclare the functions</span> <span class="cwebmacronumber">6.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">chapter</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">;</span>
        <span class="reserved">section</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">LOOP_WITHIN_TANGLE</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="functiontext"><a href="3-tt.html#SP4">Tangler::primary_target</a></span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">function_defined</span><span class="plain">) &amp;&amp; (</span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="identifier">owning_paragraph</span><span class="plain">-&gt;</span><span class="element">placed_very_early</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">)) {</span>
                <span class="reserved">language_function</span><span class="plain"> *</span><span class="identifier">fn</span><span class="plain"> = </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">function_defined</span><span class="plain">;</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">to_close</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">no_conditionals</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                    <span class="reserved">match_results</span><span class="plain"> </span><span class="identifier">mr</span><span class="plain"> = </span><span class="functiontext"><a href="4-pm.html#SP9">Regexp::create_mr</a></span><span class="plain">();</span>
                    <span class="reserved">if</span><span class="plain"> (!(</span><span class="functiontext"><a href="4-pm.html#SP10">Regexp::match</a></span><span class="plain">(&amp;</span><span class="identifier">mr</span><span class="plain">, </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">within_conditionals</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]-&gt;</span><span class="element">text</span><span class="plain">,</span>
                        <span class="identifier">L</span><span class="string">"%c*inweb: always predeclare%c*"</span><span class="plain">))) {</span>
                        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%S\n"</span><span class="plain">, </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">within_conditionals</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]-&gt;</span><span class="element">text</span><span class="plain">);</span>
                        <span class="identifier">to_close</span><span class="plain">++;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="functiontext"><a href="2-tgs.html#SP7">Tags::open_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
                <span class="functiontext"><a href="4-lm.html#SP15">LanguageMethods::insert_line_marker</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">main_language</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%S "</span><span class="plain">, </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_type</span><span class="plain">);</span>
                <span class="functiontext"><a href="4-lm.html#SP19">LanguageMethods::tangle_code</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">main_language</span><span class="plain">, </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_name</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"(%S;\n"</span><span class="plain">, </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_arguments</span><span class="plain">);</span>
                <span class="functiontext"><a href="2-tgs.html#SP7">Tags::close_ifdefs</a></span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">-&gt;</span><span class="element">owning_paragraph</span><span class="plain">);</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">to_close</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"#endif\n"</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Overriding regular code weaving. </b>We have the opportunity here to sidestep the regular weaving algorithm, and do
our own thing. We decline.
</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Analysis. </b>Having found all those functions and structure elements, we make sure they
are all known to Inweb's hash table of interesting identifiers:
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::analyse_code<button class="popup" onclick="togglePopup('usagePopup187')">...<span class="popuptext" id="usagePopup187">Usage of <b>CLike::analyse_code</b>:<br><a href="#SP1">&#167;1</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">web</span><span class="plain"> *</span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">language_function</span><span class="plain"> *</span><span class="identifier">fn</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">fn</span><span class="plain">, </span><span class="reserved">language_function</span><span class="plain">)</span>
            <span class="functiontext"><a href="3-ta.html#SP9">Analyser::find_hash_entry_for_section</a></span><span class="plain">(</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_header_at</span><span class="plain">-&gt;</span><span class="element">owning_section</span><span class="plain">,</span>
                <span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_name</span><span class="plain">, </span><span class="constant">TRUE</span><span class="plain">);</span>
        <span class="reserved">language_type</span><span class="plain"> *</span><span class="identifier">str</span><span class="plain">;</span>
        <span class="reserved">structure_element</span><span class="plain"> *</span><span class="identifier">elt</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">str</span><span class="plain">, </span><span class="reserved">language_type</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">language_types</span><span class="plain">)</span>
            <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">elt</span><span class="plain">, </span><span class="reserved">structure_element</span><span class="plain">, </span><span class="identifier">str</span><span class="plain">-&gt;</span><span class="element">elements</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">elt</span><span class="plain">-&gt;</span><span class="element">allow_sharing</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">)</span>
                    <span class="functiontext"><a href="3-ta.html#SP9">Analyser::find_hash_entry_for_section</a></span><span class="plain">(</span><span class="identifier">elt</span><span class="plain">-&gt;</span><span class="element">element_created_at</span><span class="plain">-&gt;</span><span class="element">owning_section</span><span class="plain">,</span>
                        <span class="identifier">elt</span><span class="plain">-&gt;</span><span class="element">element_name</span><span class="plain">, </span><span class="constant">TRUE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>The following is an opportunity for us to scold the author for any
specifically C-like errors. We're going to look for functions named
<code class="display"><span class="extract">Whatever::name()</span></code> whose definitions are not in the <code class="display"><span class="extract">Whatever::</span></code> section;
in other words, we police the rule that functions actually are defined in the
namespace which their names imply. This can be turned off with a special
bibliographic variable, but don't do that.
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">CLike::post_analysis<button class="popup" onclick="togglePopup('usagePopup188')">...<span class="popuptext" id="usagePopup188">Usage of <b>CLike::post_analysis</b>:<br><a href="#SP1">&#167;1</a></span></button></span><span class="plain">(</span><span class="reserved">programming_language</span><span class="plain"> *</span><span class="identifier">self</span><span class="plain">, </span><span class="reserved">web</span><span class="plain"> *</span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">check_namespaces</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="4-sm.html#SP21">Str::eq_wide_string</a></span><span class="plain">(</span><span class="functiontext"><a href="8-bdfw.html#SP6">Bibliographic::get_datum</a></span><span class="plain">(</span><span class="identifier">W</span><span class="plain">-&gt;</span><span class="element">md</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"Namespaces"</span><span class="plain">), </span><span class="identifier">L</span><span class="string">"On"</span><span class="plain">)) </span><span class="identifier">check_namespaces</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="reserved">language_function</span><span class="plain"> *</span><span class="identifier">fn</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">fn</span><span class="plain">, </span><span class="reserved">language_function</span><span class="plain">) {</span>
            <span class="reserved">hash_table_entry</span><span class="plain"> *</span><span class="identifier">hte</span><span class="plain"> =</span>
                <span class="functiontext"><a href="3-ta.html#SP9">Analyser::find_hash_entry_for_section</a></span><span class="plain">(</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_header_at</span><span class="plain">-&gt;</span><span class="element">owning_section</span><span class="plain">,</span>
                    <span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_name</span><span class="plain">, </span><span class="constant">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">hte</span><span class="plain">) {</span>
                <span class="reserved">hash_table_entry_usage</span><span class="plain"> *</span><span class="identifier">hteu</span><span class="plain">;</span>
                <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">hteu</span><span class="plain">, </span><span class="reserved">hash_table_entry_usage</span><span class="plain">, </span><span class="identifier">hte</span><span class="plain">-&gt;</span><span class="element">usages</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">hteu</span><span class="plain">-&gt;</span><span class="identifier">form_of_usage</span><span class="plain"> &amp; </span><span class="constant">FCALL_USAGE</span><span class="plain">) || (</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">within_namespace</span><span class="plain">))</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">hteu</span><span class="plain">-&gt;</span><span class="identifier">usage_recorded_at</span><span class="plain">-&gt;</span><span class="element">under_section</span><span class="plain"> != </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_header_at</span><span class="plain">-&gt;</span><span class="element">owning_section</span><span class="plain">)</span>
                            <span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">called_from_other_sections</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">within_namespace</span><span class="plain"> != </span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="identifier">called_from_other_sections</span><span class="plain">)</span>
                <span class="plain">&amp;&amp; (</span><span class="identifier">check_namespaces</span><span class="plain">)</span>
                <span class="plain">&amp;&amp; (</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">call_freely</span><span class="plain"> == </span><span class="constant">FALSE</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">within_namespace</span><span class="plain">)</span>
                    <span class="functiontext"><a href="1-pc.html#SP8">Main::error_in_web</a></span><span class="plain">(</span>
                        <span class="identifier">I</span><span class="string">"Being internally called, this function mustn't belong to a :: namespace"</span><span class="plain">,</span>
                        <span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_header_at</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="functiontext"><a href="1-pc.html#SP8">Main::error_in_web</a></span><span class="plain">(</span>
                        <span class="identifier">I</span><span class="string">"Being externally called, this function must belong to a :: namespace"</span><span class="plain">,</span>
                        <span class="identifier">fn</span><span class="plain">-&gt;</span><span class="element">function_header_at</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="4-tp.html">Back to 'The Painter'</a></li><li><a href="4-is.html">Continue with 'InC Support'</a></li></ul><hr class="tocbar">
<!--End of weave-->
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
		</main>
	</body>
</html>

