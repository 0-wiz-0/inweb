<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>M/awwp</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../inweb/index.html">inweb</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../foundation-module/index.html">foundation-module</a></li>
<li><a href="../foundation-test/index.html">foundation-test</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of 'M/spl' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="index.html">inweb</a></li><li><a href="index.html#M">Manual</a></li><li><b>Supporting Programming Languages</b></li></ul><p class="purpose">How to work with a programming language not yet supported by Inweb.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Introduction</a></li><li><a href="#SP4">&#167;4. Structure of language definitions</a></li><li><a href="#SP5">&#167;5. Properties</a></li><li><a href="#SP16">&#167;16. Secret Features</a></li><li><a href="#SP17">&#167;17. Keywords</a></li><li><a href="#SP18">&#167;18. Syntax colouring program</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Introduction. </b>To a very large extent, Inweb works the same way regardless of what language
its webs are using, and that is deliberate. On the other hand, when a web
is woven, it will look much nicer with syntax-colouring, and that clearly
can't be done without at least a surface understanding of what programs in
the language mean.
</p>

<p class="inwebparagraph">As we've seen, the Contents section of a web has to specify its language.
For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Language: Perl</span>
</pre>

<p class="inwebparagraph">declares that the program expressed by the web is a Perl script. The language
name must be one which Inweb knows, or, more exactly, one for which it can
find a "language definition file". These are stored in the <code class="display"><span class="extract">Languages</span></code>
subdirectory of the <code class="display"><span class="extract">inweb</span></code> distribution, and if a language is called <code class="display"><span class="extract">L</span></code>
then its file is <code class="display"><span class="extract">L.ildf</span></code>. You can see the languages currently available
to Inweb by using <code class="display"><span class="extract">-show-languages</span></code>. At present, a newly installed Inweb
replies like so:
</p>

<pre>
    Inweb can see the following programming language definitions:

    Inform 7: The natural-language based language Inform 7
    InC: The Inform-tools extension to the C programming language
    Inform 6: The C-like interactive fiction language Inform 6
    C++: The C++ programming language
    None: For programs in languages not yet supported by Inweb
    ILDF: The Inweb Language Definition File format
    Plain Text: For text files which are not programs
    Perl: The scripting language Perl 5
    C: The C programming language
    ACME: The ACME assembly language for 6502 and related CPUs

</pre>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>So what if you want to write a literate program in a language not on that
list? One option is to give the language as <code class="display"><span class="extract">None</span></code>. (Note that this is
different from simply not declaring a language &mdash; if your web doesn't say
what language it is, Inweb assumes C.) <code class="display"><span class="extract">None</span></code> is fine for tangling, though
it has the minor annoyance that it tangles to a file with the filename
extension <code class="display"><span class="extract">.txt</span></code>, not knowing any better. But you can cure that with
<code class="display"><span class="extract">-tangle-to F</span></code> for any filename <code class="display"><span class="extract">F</span></code> of your choice. With weaving, though,
<code class="display"><span class="extract">None</span></code> makes for drab-looking weaves, because there's very little syntax
colouring.
</p>

<p class="inwebparagraph">An even more extreme option is <code class="display"><span class="extract">Plain Text</span></code>, which has no syntax colouring
at all. (But this could still be useful if what you want is to produce an
annotated explanation of some complicated configuration file in plain text.)
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>In fact, though, it's easy to make new language definitions, and if you're
spending any serious effort on a web of a program in an unsupported language
then it's probably worth making one. Contributions of these to the Inweb
open source project are welcome, and then this effort might also benefit others.
This section of the manual is about how to do it.
</p>

<p class="inwebparagraph">Once you have written a definition, use <code class="display"><span class="extract">-read-language L</span></code> at the command
line, where <code class="display"><span class="extract">L</span></code> is the file defining it. If you have many custom languages,
<code class="display"><span class="extract">-read-languages D</span></code> reads all of the definitions in a directory <code class="display"><span class="extract">D</span></code>.
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Structure of language definitions. </b>Each language is defined by a single ILDF file. (Inweb Language Definition
Format: and there is in fact an ILDF file for ILDF itself.) In this section,
we'll call it the ILD.
</p>

<p class="inwebparagraph">The ILD is a plain text file, which is read in line by line. Leading and
trailing whitespace on each line is ignored; blank lines are ignored; and
so are comments, which are lines beginning with a <code class="display"><span class="extract">#</span></code> character.
</p>

<p class="inwebparagraph">The ILD contains three sorts of thing:
</p>

<ul class="items"><li>(a) Properties, set by lines in the form <code class="display"><span class="extract">Name: C++</span></code>.
</li><li>(b) Keywords, set by lines in the form <code class="display"><span class="extract">keyword int</span></code>.
</li><li>(c) A colouring program, introduced by <code class="display"><span class="extract">colouring {</span></code> and continuing until the
last block of it is closed with a <code class="display"><span class="extract">}</span></code>.
</li></ul>
<p class="inwebparagraph">Everything in an ILD is optional, so a minimal ILD is in principle empty. In
practice, though, every ILD should open like so:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Name: C</span>
        <span class="plain">Details: The C programming language</span>
        <span class="plain">Extension: .c</span>
</pre>

<p class="inwebparagraph">Example:
</p>

<pre>
    Name: Perl
    iiiippiiii
    Details: The scripting language Perl 5
    iiiiiiippiiipiiiiiiiiipiiiiiiiipiiiipn
    Extension: .pl
    iiiiiiiiipppii
    Line Comment: #
    iiiipiiiiiiippp
    String Literal: "
    iiiiiipiiiiiiippp
    String Literal Escape: \
    iiiiiipiiiiiiipiiiiiippp
    Character Literal: '
    iiiiiiiiipiiiiiiippp
    Character Literal Escape: \
    iiiiiiiiipiiiiiiipiiiiiippp


    Shebang: #!/usr/bin/perl\n\n
    iiiiiiipppppiiipiiipiiiipipi
    Before Named Paragraph Expansion: \n{\n
    iiiiiipiiiiipiiiiiiiiipiiiiiiiiipppippi
    After Named Paragraph Expansion: }\n
    iiiiipiiiiipiiiiiiiiipiiiiiiiiippppi
    Start Definition: %S =
    iiiiipiiiiiiiiiipppipp
    End Definition: \n;\n
    iiipiiiiiiiiiipppippi


    # In its usual zany way, Perl recognises the same #line syntax as C, thus in
    p!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # principle overloading its comment notation #:
    p!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    Line Marker: #line %d "%f"\n
    iiiipiiiiiipppiiiippipppippi


</pre>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Properties. </b>Inevitably, there's a miscellaneous shopping list of these, but let's start
with the semi-compulsory ones.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Name</span></code>. This is the one used by webs in their <code class="display"><span class="extract">Language: X</span></code> lines, and should
match the ILD's own filename: wherever it is stored, the ILD for langauge <code class="display"><span class="extract">X</span></code>
should be filenamed <code class="display"><span class="extract">X.ildf</span></code>.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Details</span></code> These are used only by <code class="display"><span class="extract">-show-languages</span></code>.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Extension</span></code>. The default file extension used when a web in this format is
tangled. Thus, a web for a C program called <code class="display"><span class="extract">something</span></code> will normally tangle
to a file called <code class="display"><span class="extract">something.c</span></code>.
</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>Most programming languages contain comments. In some, like Perl, a comment
begins with a triggering notation (in Perl's case, <code class="display"><span class="extract">#</span></code>) occurring outside of
quoted material; and it continues to the end of its line. We'll call that a
"line comment". There are also languages where comments must be the only
non-whitespace items on their lines: in that case, we'll call them "whole
line comments". In others, like Inform 7, a comment begins with one notation
<code class="display"><span class="extract">[</span></code> and ends with another <code class="display"><span class="extract">]</span></code>, not necessarily on the same line. We'll call
those "multiline comments".
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Line Comment</span></code> is the notation for line comments, and <code class="display"><span class="extract">Whole Line Comment</span></code> is
the notation for whole line comments.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Multiline Comment Open</span></code> and <code class="display"><span class="extract">Multiline Comment Close</span></code>, which should exist
as a pair or not at all, is the notation for multiline comments.
</p>

<p class="inwebparagraph">For example, C defines:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Multiline Comment Open: /*</span>
        <span class="plain">Multiline Comment Close: */</span>
        <span class="plain">Line Comment: //</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>As noted, comments occur only outside of string or character literals. We
can give notations for these as follows:
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">String Literal</span></code> must be a single character, and marks both start and end.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">String Literal Escape</span></code> is the escape character within a string literal to
express an instance of the <code class="display"><span class="extract">String Literal</span></code> character without ending it.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Character Literal</span></code> and <code class="display"><span class="extract">Character Literal Escape</span></code> are the same thing for
character literals.
</p>

<p class="inwebparagraph">Here, C defines:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">String Literal: "</span>
        <span class="plain">String Literal Escape: \</span>
        <span class="plain">Character Literal: '</span>
        <span class="plain">Character Literal Escape: \</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>Next, numeric literals, like <code class="display"><span class="extract">0xFE45</span></code> in C, or <code class="display"><span class="extract">$$10011110</span></code> in Inform 6.
It's assumed that every language allows non-negative decimal numbers.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Binary Literal Prefix</span></code>, <code class="display"><span class="extract">Octal Literal Prefix</span></code>, and <code class="display"><span class="extract">Hexadecimal Literal Prefix</span></code>
are notations for non-decimal numbers, if they exist.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Negative Literal Prefix</span></code> allows negative decimals: this is usually <code class="display"><span class="extract">-</span></code> if set.
</p>

<p class="inwebparagraph">Here, C has:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Hexadecimal Literal Prefix: 0x</span>
        <span class="plain">Binary Literal Prefix: 0b</span>
        <span class="plain">Negative Literal Prefix: -</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b><code class="display"><span class="extract">Shebang</span></code> is used only in tangling, and is a probably short text added at
the very beginning of a tangled program. This is useful for scripting languages
in Unix, where the opening line must be a "shebang" indicating their language.
For example, Perl defines:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Shebang: #!/usr/bin/perl\n\n</span>
</pre>

<p class="inwebparagraph">Most languages do not have a shebang.
</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>In order for C compilers to report C syntax errors on the correct line,
despite rearranging by automatic tools, C conventionally recognises the
preprocessor directive <code class="display"><span class="extract">#line</span></code> to tell it that a contiguous extract follows
from the given file. Quite a few languages support notations like this,
which most users never use.
</p>

<p class="inwebparagraph">When tangling, Inweb is just such a rearranging tool, and it inserts line
markers automatically for languages which support them: <code class="display"><span class="extract">Line Marker</span></code> specifies
that this language does, and gives the notation. For example, C provides:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Line Marker: #line %d "%f"\n</span>
</pre>

<p class="inwebparagraph">Here <code class="display"><span class="extract">%d</span></code> expands to the line number, and <code class="display"><span class="extract">%f</span></code> the filename, of origin.
</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>When a named paragraph is used in code, and the tangler is "expanding" it
to its contents, it can optionally place some material before and after the
matter added. This material is in <code class="display"><span class="extract">Before Named Paragraph Expansion</span></code> and
<code class="display"><span class="extract">After Named Paragraph Expansion</span></code>, which are by default empty.
</p>

<p class="inwebparagraph">For C and all similar languages, we recommend this:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Before Named Paragraph Expansion: \n{\n</span>
        <span class="plain">After Named Paragraph Expansion: }\n</span>
</pre>

<p class="inwebparagraph">The effect of this is to ensure that code such as:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">if (x == y) @&lt;Do something dramatic@&gt;;</span>
</pre>

<p class="inwebparagraph">tangles to something like this:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">if (x == y)</span>
        <span class="plain">{</span>
        <span class="plain">...</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">so that any variables defined inside "Do something dramatic" have limited
scope, and so that multi-line macros are treated as a single statement by <code class="display"><span class="extract">if</span></code>,
<code class="display"><span class="extract">while</span></code> and so on.
</p>

<p class="inwebparagraph">(The new-line before the opening brace is not for aesthetic purposes; we never
care much about the aesthetics of tangled C code, which is not for human eyes.
It's in case of any problems arising with line comments.)
</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>When the author of a web makes definitions with <code class="display"><span class="extract">@d</span></code> or <code class="display"><span class="extract">@e</span></code>, Inweb will
need to tangle those into valid constant definitions in the language concerned.
It can only do so if the language provides a notation for that.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">Start Definition</span></code> begins; <code class="display"><span class="extract">Prolong Definition</span></code>, if given, shows how to
continue a multiline definition (if they are allowed); and <code class="display"><span class="extract">End Definition</span></code>,
if given, places any ending notation. For example, Inform 6 defines:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Start Definition: Constant %S =\s</span>
        <span class="plain">End Definition: ;\n</span>
</pre>

<p class="inwebparagraph">where <code class="display"><span class="extract">%S</span></code> expands to the name of the term to be defined. Thus, we might tangle
out to:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Constant TAXICAB = 1729;\n</span>
</pre>

<p class="inwebparagraph">Inweb ignores all definitions unless one of these three properties is given.
</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>Inweb needs a notation for conditional compilation in order to handle some
of its advanced features for tangling tagged material: the Inform project
makes use of this to handle code dependent on the operating system in use.
If the language supports it, the notation is in <code class="display"><span class="extract">Start Ifdef</span></code> and <code class="display"><span class="extract">End Ifdef</span></code>,
and in <code class="display"><span class="extract">Start Ifndef</span></code> and <code class="display"><span class="extract">End Ifndef</span></code>. For example, Inform 6 has:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Start Ifdef: #ifdef %S;\n</span>
        <span class="plain">End Ifdef: #endif; ! %S\n</span>
        <span class="plain">Start Ifndef: #ifndef %S;\n</span>
        <span class="plain">End Ifndef: #endif; ! %S\n</span>
</pre>

<p class="inwebparagraph">which is a subtly different notation from the C one. Again, <code class="display"><span class="extract">%S</span></code> expands to
the name of the term we are conditionally compiling on.
</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b><code class="display"><span class="extract">Supports Namespaces</span></code> must be either <code class="display"><span class="extract">true</span></code> or <code class="display"><span class="extract">false</span></code>, and is by default
<code class="display"><span class="extract">false</span></code>. If set, then the language allows identifier names to include
dividers with the notation <code class="display"><span class="extract">::</span></code>; section headings can declare that all of
their code belongs to a single namespace; and any functions detected in that
code must have a name using that namespace.
</p>

<p class="inwebparagraph">This is a rudimentary way to provide namespaces to languages not otherwise
having them: InC uses it to extend C.
</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b><code class="display"><span class="extract">Suppress Disclaimer</span></code> is again <code class="display"><span class="extract">true</span></code> or <code class="display"><span class="extract">false</span></code>, and by default <code class="display"><span class="extract">false</span></code>.
The disclaimer is a comment placed into a tangle declaring that the file
has been auto-generated by Inweb and shouldn't be edited. (The comment
only appears in comment notation has been declared for the language: so
e.g., the Plain Text ILD doesn't need to be told to <code class="display"><span class="extract">Suppress Disclaimer</span></code>
since it cannot tangle comments anyway.)
</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Secret Features. </b>It is not quite true that everything a language can do is defined by the ILD.
Additional features are provided to C-like languages to detect functions
and <code class="display"><span class="extract">typedef</span></code>s. At present, these are hard-wired into Inweb, and it will take
further thought to work out how to express them in LDFs.
</p>

<p class="inwebparagraph">The property <code class="display"><span class="extract">C-Like</span></code>, by default <code class="display"><span class="extract">false</span></code>, enables these features.
</p>

<p class="inwebparagraph">(In addition, a language whose name is <code class="display"><span class="extract">InC</span></code> gets still more features, but
those are not so much a failing of ILDF as because Inweb is itself a sort of
compiler for <code class="display"><span class="extract">InC</span></code> &mdash; see elsewhere in this manual.)
</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Keywords. </b>Syntax colouring is greatly helped by knowing that certain identifier names
are special: for example, <code class="display"><span class="extract">void</span></code> is special in C. These are often called
"reserved words", in that they can't be used as variable or function names
in the language in question. For C, then, we include the line:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">keyword void</span>
</pre>

<p class="inwebparagraph">Keywords can be declared in a number of categories, which are identified by
colour name: the default is <code class="display"><span class="extract">!reserved</span></code>, the colour for reserved words. But
for example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">keyword isdigit of !function</span>
</pre>

<p class="inwebparagraph">makes a keyword of colour <code class="display"><span class="extract">!function</span></code>.
</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Syntax colouring program. </b>That leads nicely into how syntax colouring is done.
</p>

<p class="inwebparagraph">ILDs have no control over what colours or typefaces are used: that's all
controllable, but is done by changing the weave pattern. So we can't colour
a word "green": instead we colour it semantically, from the following
palette of possibilities:
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">!string</span></code>, <code class="display"><span class="extract">!function</span></code>, <code class="display"><span class="extract">!definition</span></code>, <code class="display"><span class="extract">!reserved</span></code>, <code class="display"><span class="extract">!element</span></code>, <code class="display"><span class="extract">!identifier</span></code>,
<code class="display"><span class="extract">!character</span></code>, <code class="display"><span class="extract">!constant</span></code>, <code class="display"><span class="extract">!plain</span></code>, <code class="display"><span class="extract">!extract</span></code>, <code class="display"><span class="extract">!comment</span></code>
</p>

<p class="inwebparagraph">Each character has its own colour. At the start of the process, every
character is <code class="display"><span class="extract">!plain</span></code>.
</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>At the first stage, Inweb uses the language's comment syntax to work out
what part of the code is commentary, and what part is "live". Only the live
part goes forward into stage two. All comment material is coloured <code class="display"><span class="extract">!comment</span></code>.
</p>

<p class="inwebparagraph">At the second stage, Inweb uses the syntax for literals. Character literals
are painted in <code class="display"><span class="extract">!character</span></code>, string literals in <code class="display"><span class="extract">!string</span></code>, identifiers in
<code class="display"><span class="extract">!identifier</span></code>, and numeric literals as <code class="display"><span class="extract">!constant</span></code>.
</p>

<p class="inwebparagraph">At the third stage, Inweb runs the colouring program for the language (if
one is provided): it has the opportunity to apply some polish. Note that this
runs only on the live material; it cannot affect the commented-out matter.
</p>

<p class="inwebparagraph">When a colouring program begins running, then, everything is coloured in
one of the following: <code class="display"><span class="extract">!character</span></code>, <code class="display"><span class="extract">!string</span></code>, <code class="display"><span class="extract">!identifier</span></code>, <code class="display"><span class="extract">!constant</span></code>,
and <code class="display"><span class="extract">!plain</span></code>.
</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b>A colouring program begins with <code class="display"><span class="extract">colouring {</span></code> and ends with <code class="display"><span class="extract">}</span></code>. The
empty program is legal but does nothing:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">colouring {</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">The material between the braces is called a "block". Each block runs on a
given stretch of contiguous text, called the "snippet". For the outermost
block, that's a line of source code. Blocks normally contain one or more
"rules":
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">colouring {</span>
        <span class="plain">    marble =&gt; !extract</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">Rules take the form of "if X, then Y", and the <code class="display"><span class="extract">=&gt;</span></code> divides the X from the Y.
This one says that if the snippet consists of the word "marble", then colour
it <code class="display"><span class="extract">!extract</span></code>. Of course this is not very useful, since it would only catch
lines containing only that one word. So we really want to narrow in on smaller
snippets:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">colouring {</span>
        <span class="plain">    characters {</span>
        <span class="plain">        X =&gt; !extract</span>
        <span class="plain">    }</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">The effect of the <code class="display"><span class="extract">characters {</span></code> ... <code class="display"><span class="extract">}</span></code> block is to apply all its rules to
each character of the snippet owning it. Inside the block, then, the snippet
is always just a single character, and our rule tells us to paint the letter X
wherever it occurs.
</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b>The block <code class="display"><span class="extract">instances of X</span></code> narrows in on each usage of the text <code class="display"><span class="extract">X</span></code> inside
the snippet. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">colouring {</span>
        <span class="plain">    instances of == {</span>
        <span class="plain">        =&gt; !reserved</span>
        <span class="plain">    }</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">gives every usage of <code class="display"><span class="extract">==</span></code> the colour <code class="display"><span class="extract">!reserved</span></code>. Note that it never runs in
an overlapping way: the snippet <code class="display"><span class="extract">===</span></code> would be considered as having only one
instance of <code class="display"><span class="extract">==</span></code> (the first two characters), while <code class="display"><span class="extract">====</span></code> would have two.
</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b>Another kind of block is <code class="display"><span class="extract">runs of C</span></code>, where <code class="display"><span class="extract">C</span></code> is a colour. For example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">colouring {</span>
        <span class="plain">    runs of !identifier {</span>
        <span class="plain">        printf =&gt; !function</span>
        <span class="plain">        sscanf =&gt; !function</span>
        <span class="plain">    }</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">If this runs on the line <code class="display"><span class="extract">if (x == 1) printf("Hello!");</span></code>, then the inner
block will run three times: its snippet will be <code class="display"><span class="extract">if</span></code>, then <code class="display"><span class="extract">x</span></code>, then <code class="display"><span class="extract">printf</span></code>.
The rules inside the block will take effect only on the third time, when it
will paint the word <code class="display"><span class="extract">printf</span></code> in <code class="display"><span class="extract">!function</span></code> colour.
</p>

<p class="inwebparagraph">As a special form, <code class="display"><span class="extract">runs of unquoted</span></code> means "runs of characters not painted
either with <code class="display"><span class="extract">!string</span></code> or <code class="display"><span class="extract">!character</span></code>". This is special because <code class="display"><span class="extract">unquoted</span></code> is
not a colour.
</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23.  </b>It remains to specify what rules can do. As noted, they take the form
"if X, then Y". The following are the possibilities for X, the condition:
</p>

<p class="inwebparagraph">1. X can be omitted altogether, and then the rule always applies. For example,
this somewhat nihilistic program gets rid of colouring entirely:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">colouring {</span>
        <span class="plain">    =&gt; !plain</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">2. X can require the whole snippet to be of a particular colour, by writing
<code class="display"><span class="extract">colour C</span></code>. For example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">colouring {</span>
        <span class="plain">    characters {</span>
        <span class="plain">        colour !character =&gt; !plain</span>
        <span class="plain">    }</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">removes the syntax colouring on character literals.
</p>

<p class="inwebparagraph">3. X can require the snippet to be one of the language's known keywords, as
declared earlier in the ILD by a <code class="display"><span class="extract">keyword</span></code> command. The syntax here is
<code class="display"><span class="extract">keyword of C</span></code>, where <code class="display"><span class="extract">C</span></code> is a colour. For example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">keyword of !element =&gt; !element</span>
</pre>

<p class="inwebparagraph">says: if the snippet is a keyword declared as being of colour <code class="display"><span class="extract">!element</span></code>,
then actually colour it that way.
</p>

<p class="inwebparagraph">4. X can look at a little context before or after the snippet, testing it
with one of the following: <code class="display"><span class="extract">prefix P</span></code>, <code class="display"><span class="extract">spaced prefix P</span></code>,
<code class="display"><span class="extract">optionally spaced prefix P</span></code>. These qualifiers have to do with whether white
space must appear after <code class="display"><span class="extract">P</span></code> and before the snippet. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">runs of !identifier {</span>
        <span class="plain">    prefix optionally spaced -&gt; =&gt; !element</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">means that any identifier occurring after a <code class="display"><span class="extract">-&gt;</span></code> token will be coloured
as <code class="display"><span class="extract">!element</span></code>. Similarly for <code class="display"><span class="extract">suffix</span></code>.
</p>

<p class="inwebparagraph">5. And otherwise X is literal text, and the rule applies if and only if
the snippet is exactly that text. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">printf =&gt; !function</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24.  </b>Now let's look at the conclusion Y of a rule. Here the possibilities are
simpler:
</p>

<p class="inwebparagraph">1. If Y is the name of a colour, the snippet is painted in that colour.
</p>

<p class="inwebparagraph">2. If Y is an open brace <code class="display"><span class="extract">{</span></code>, then it introduces a block of rules which are
applied to the snippet only if this rule has matched. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">keyword !element =&gt; {</span>
        <span class="plain">    optionally spaced prefix . =&gt; !element</span>
        <span class="plain">    optionally spaced prefix -&gt; =&gt; !element</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph">means that if the original condition <code class="display"><span class="extract">keyword !element</span></code> applies, then two
further rules are applied.
</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25.  </b>The syntax of ILDs tends to avoid superfluous quotation marks as confusing,
but sometimes you need to be pedantic. If you want to match the text <code class="display"><span class="extract">=&gt;</span></code>,
for example, that could lead to ambiguity with the rule marker <code class="display"><span class="extract">=&gt;</span></code>. For
such occasions, simply put the text in double quotes, and change any literal
double quote in it to <code class="display"><span class="extract">\"</span></code>, and use <code class="display"><span class="extract">\\</span></code> for a literal backslash. For example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">"keyword" =&gt; !reserved</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="M-awwp.html">Back to 'Advanced Weaving with Patterns'</a></li><li><a href="M-rc.html">Continue with 'Reference Card'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

