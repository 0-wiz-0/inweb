<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>The Sieve of Eratosthenes</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Inweb Source</a></h1>
<ul>
<li><a href="../inweb/index.html">inweb</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../foundation-module/index.html">foundation-module</a></li>
<li><a href="../foundation-test/index.html">foundation-test</a></li>
</ul>
<h2>Example Webs</h2>
<ul>
<li><a href="../goldbach/index.html">goldbach</a></li>
<li><a href="../twinprimes/twinprimes.html">twinprimes</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of 'The Sieve of Eratosthenes' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Home</a></li><li><a href="index.html">goldbach</a></li><li><b>The Sieve of Eratosthenes</b></li></ul><p class="purpose">A fairly fast way to determine if small numbers are prime, given storage.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Storage</a></li><li><a href="#SP2">&#167;2. Primality</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Storage. </b>This technique, still essentially the best sieve for finding prime
numbers, is attributed to Eratosthenes of Cyrene and dates from the 200s BC.
Since composite numbers are exactly those numbers which are multiples of
something, the idea is to remove everything which is a multiple: whatever
is left, must be prime.
</p>

<p class="inwebparagraph">This is very fast (and can be done more quickly than the implementation
below), but (a) uses storage to hold the sieve, and (b) has to start right
back at 2 - so it can't efficiently test just, say, the eight-digit numbers
for primality.
</p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">still_in_sieve</span><span class="plain">[</span><span class="constant">RANGE</span><span class="plain"> + </span><span class="constant">1</span><span class="plain">];</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">sieve_performed</span><span class="plain"> = </span><span class="constant">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Primality. </b>We provide this as a function which determines whether a number is prime:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">TRUE</span><span class="plain"> </span><span class="constant">1</span>
    <span class="definitionkeyword">define</span> <span class="constant">FALSE</span><span class="plain"> </span><span class="constant">0</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">isprime<button class="popup" onclick="togglePopup('usagePopup0')">...<span class="popuptext" id="usagePopup0">Usage of <b>isprime</b>:<br>The Goldbach Conjecture - <a href="S-tgc.html#SP1_1">&#167;1.1</a></span></button></span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">n</span><span class="plain"> &lt;= </span><span class="constant">1</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">n</span><span class="plain"> &gt; </span><span class="constant">RANGE</span><span class="plain">) { </span><span class="identifier">printf</span><span class="plain">(</span><span class="string">"Out of range!\n"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">; }</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="identifier">sieve_performed</span><span class="plain">) </span>&lt;<span class="cwebmacro">Perform the sieve</span> <span class="cwebmacronumber">2.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">still_in_sieve</span><span class="plain">[</span><span class="identifier">n</span><span class="plain">];</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2_1"></a><b>&#167;2.1.  </b>We save a little time by noting that if a number up to <code class="display"><span class="extract">RANGE</span></code> is composite
then one of its factors must be smaller than the square root of <code class="display"><span class="extract">RANGE</span></code>. Thus,
in a sieve of size 10000, one only needs to remove multiples of 2 up to 100,
for example.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Perform the sieve</span> <span class="cwebmacronumber">2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        &lt;<span class="cwebmacro">Start with all numbers from 2 upwards in the sieve</span> <span class="cwebmacronumber">2.1.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain">=2; </span><span class="identifier">n</span><span class="plain">*</span><span class="identifier">n</span><span class="plain"> &lt;= </span><span class="constant">RANGE</span><span class="plain">; </span><span class="identifier">n</span><span class="plain">++)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">still_in_sieve</span><span class="plain">[</span><span class="identifier">n</span><span class="plain">])</span>
                &lt;<span class="cwebmacro">Shake out multiples of n</span> <span class="cwebmacronumber">2.1.2</span>&gt;<span class="plain">;</span>
        <span class="identifier">sieve_performed</span><span class="plain"> = </span><span class="constant">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2">&#167;2</a>.</p>

<p class="inwebparagraph"><a id="SP2_1_1"></a><b>&#167;2.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Start with all numbers from 2 upwards in the sieve</span> <span class="cwebmacronumber">2.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">still_in_sieve</span><span class="plain">[1] = </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain">=2; </span><span class="identifier">n</span><span class="plain"> &lt;= </span><span class="constant">RANGE</span><span class="plain">; </span><span class="identifier">n</span><span class="plain">++) </span><span class="identifier">still_in_sieve</span><span class="plain">[</span><span class="identifier">n</span><span class="plain">] = </span><span class="constant">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_1">&#167;2.1</a>.</p>

<p class="inwebparagraph"><a id="SP2_1_2"></a><b>&#167;2.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Shake out multiples of n</span> <span class="cwebmacronumber">2.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">m</span><span class="plain">= </span><span class="identifier">n</span><span class="plain">+</span><span class="identifier">n</span><span class="plain">; </span><span class="identifier">m</span><span class="plain"> &lt;= </span><span class="constant">RANGE</span><span class="plain">; </span><span class="identifier">m</span><span class="plain"> += </span><span class="identifier">n</span><span class="plain">) </span><span class="identifier">still_in_sieve</span><span class="plain">[</span><span class="identifier">m</span><span class="plain">] = </span><span class="constant">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2_1">&#167;2.1</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-tgc.html">Back to 'The Goldbach Conjecture'</a></li><li><i>(This section ends Sections.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
		</main>
	</body>
</html>

