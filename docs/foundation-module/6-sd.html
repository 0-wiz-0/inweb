<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>6/id</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '6/sd' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">foundation</a></li><li><a href="index.html#6">Chapter 6: Media</a></li><li><b>Sound Durations</b></li></ul><p class="purpose">These utility routines look at the headers of AIFF, OGG Vorbis or MIDI files to find the durations, and verify that they are what they purport to be.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. AIFF files</a></li><li><a href="#SP2">&#167;2. OGG Vorbis files</a></li><li><a href="#SP3">&#167;3. MIDI files</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. AIFF files. </b>The code in this section was once again originated by Toby Nelson. To
explicate the following, see the specifications for AIFF and OGG headers.
Durations are measured in centiseconds.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">SoundFiles::get_AIFF_duration</span><span class="plain">(</span><span class="reserved">FILE</span><span class="plain"> *</span><span class="identifier">pFile</span><span class="plain">, </span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pDuration</span><span class="plain">,</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pBitsPerSecond</span><span class="plain">, </span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pChannels</span><span class="plain">, </span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pSampleRate</span><span class="plain">) {</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sig</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">chunkID</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">chunkLength</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">numSampleFrames</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sampleSize</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sig</span><span class="plain"> != 0</span><span class="identifier">x464F524D</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">"FORM"</span></code> indicating an IFF file</span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sig</span><span class="plain"> != 0</span><span class="identifier">x41494646</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">"AIFF"</span></code> indicating an AIFF file</span>

        <span class="comment">Read chunks, skipping over those we are not interested in</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="constant">TRUE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">chunkID</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">chunkLength</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">chunkID</span><span class="plain"> == 0</span><span class="identifier">x434F4D4D</span><span class="plain">) { </span>    <span class="comment"><code class="display"><span class="extract">"COMM"</span></code> indicates common AIFF data</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">chunkLength</span><span class="plain"> &lt; 18) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">; </span>    <span class="comment">Check we have enough data to read</span>

                <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int16</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">pChannels</span><span class="plain">))          </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">numSampleFrames</span><span class="plain">))  </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int16</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sampleSize</span><span class="plain">))       </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_float80</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">pSampleRate</span><span class="plain">))      </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

                <span class="reserved">if</span><span class="plain"> (*</span><span class="identifier">pSampleRate</span><span class="plain"> == 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">; </span>    <span class="comment">Sanity check to avoid a divide by zero</span>

                <span class="comment">Result is in centiseconds</span>
                <span class="plain">*</span><span class="identifier">pDuration</span><span class="plain"> = (</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain">) (((</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">long</span><span class="plain"> </span><span class="reserved">long</span><span class="plain">) </span><span class="identifier">numSampleFrames</span><span class="plain"> * 100) / *</span><span class="identifier">pSampleRate</span><span class="plain">);</span>
                <span class="plain">*</span><span class="identifier">pBitsPerSecond</span><span class="plain"> = *</span><span class="identifier">pSampleRate</span><span class="plain"> * *</span><span class="identifier">pChannels</span><span class="plain"> * </span><span class="identifier">sampleSize</span><span class="plain">;</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="comment">Skip unwanted chunk</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, (</span><span class="reserved">long</span><span class="plain">) </span><span class="identifier">chunkLength</span><span class="plain">, </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="constant">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function SoundFiles::get_AIFF_duration appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. OGG Vorbis files. </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">SoundFiles::get_OggVorbis_duration</span><span class="plain">(</span><span class="reserved">FILE</span><span class="plain"> *</span><span class="identifier">pFile</span><span class="plain">, </span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pDuration</span><span class="plain">,</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pBitsPerSecond</span><span class="plain">, </span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pChannels</span><span class="plain">, </span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pSampleRate</span><span class="plain">) {</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sig</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">version</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">numSegments</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">packetType</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">vorbisSig1</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">vorbisSig2</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">seekPos</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">fileLength</span><span class="plain">, </span><span class="identifier">bytesToRead</span><span class="plain">, </span><span class="identifier">lastSig</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">long</span><span class="plain"> </span><span class="reserved">long</span><span class="plain"> </span><span class="identifier">granulePosition</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">char</span><span class="plain"> </span><span class="identifier">buffer</span><span class="plain">[256];</span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sig</span><span class="plain"> != 0</span><span class="identifier">x4F676753</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">"OggS"</span></code> indicating an OGG file</span>

        <span class="comment">Check OGG version is zero</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int8</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">version</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">version</span><span class="plain"> != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Skip header type, granule position, serial number, page sequence and CRC</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, 21, </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read number of page segments</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int8</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">numSegments</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Skip segment table</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, (</span><span class="reserved">long</span><span class="plain">) </span><span class="identifier">numSegments</span><span class="plain">, </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Vorbis Identification header</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int8</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">packetType</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">packetType</span><span class="plain"> != 1) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">vorbisSig1</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vorbisSig1</span><span class="plain"> != 0</span><span class="identifier">x766F7262</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;   </span>    <span class="comment"><code class="display"><span class="extract">"VORB"</span></code></span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int16</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">vorbisSig2</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vorbisSig2</span><span class="plain"> != 0</span><span class="identifier">x6973</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;   </span>    <span class="comment"><code class="display"><span class="extract">"IS"</span></code></span>

        <span class="comment">Check Vorbis version is zero</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">version</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">version</span><span class="plain"> != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read number of channels</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int8</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">pChannels</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read sample rate</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">pSampleRate</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="functiontext">BinaryFiles::swap_bytes32</span><span class="plain">(</span><span class="identifier">pSampleRate</span><span class="plain">);  </span>    <span class="comment">Ogg Vorbis uses LSB first</span>

        <span class="comment">Skip bitrate maximum</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, 4, </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read Nominal Bitrate</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">pBitsPerSecond</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="functiontext">BinaryFiles::swap_bytes32</span><span class="plain">(</span><span class="identifier">pBitsPerSecond</span><span class="plain">);  </span>    <span class="comment">Ogg Vorbis uses LSB first</span>

        <span class="comment">Encoders can be unhelpful and give no bitrate in the header</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pBitsPerSecond</span><span class="plain"> == 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Search for the final Ogg page (near the end of the file) to read duration,</span>
        <span class="comment">i.e., read the last 4K of the file and look for the final <code class="display"><span class="extract">"OggS"</span></code> sig</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, 0, </span><span class="identifier">SEEK_END</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="identifier">fileLength</span><span class="plain"> = (</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain">) </span><span class="identifier">ftell</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fileLength</span><span class="plain"> &lt; 4096) </span><span class="identifier">seekPos</span><span class="plain"> = 0;</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">seekPos</span><span class="plain"> = </span><span class="identifier">fileLength</span><span class="plain"> - 4096;</span>

        <span class="identifier">lastSig</span><span class="plain"> = 0</span><span class="identifier">xFFFFFFFF</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">seekPos</span><span class="plain"> &lt; </span><span class="identifier">fileLength</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, (</span><span class="reserved">long</span><span class="plain">) </span><span class="identifier">seekPos</span><span class="plain">, </span><span class="identifier">SEEK_SET</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="identifier">bytesToRead</span><span class="plain"> = </span><span class="identifier">fileLength</span><span class="plain"> - </span><span class="identifier">seekPos</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bytesToRead</span><span class="plain"> &gt; 256) </span><span class="identifier">bytesToRead</span><span class="plain"> = 256;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fread</span><span class="plain">(</span><span class="identifier">buffer</span><span class="plain">, 1, </span><span class="identifier">bytesToRead</span><span class="plain">, </span><span class="identifier">pFile</span><span class="plain">) != </span><span class="identifier">bytesToRead</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

            <span class="reserved">for</span><span class="plain">(</span><span class="identifier">index</span><span class="plain"> = 0; </span><span class="identifier">index</span><span class="plain"> &lt; </span><span class="identifier">bytesToRead</span><span class="plain">; </span><span class="identifier">index</span><span class="plain">++) {</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">buffer</span><span class="plain">[</span><span class="identifier">index</span><span class="plain">] == 0</span><span class="identifier">x4F</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">buffer</span><span class="plain">[</span><span class="identifier">index</span><span class="plain"> + 1] == 0</span><span class="identifier">x67</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">buffer</span><span class="plain">[</span><span class="identifier">index</span><span class="plain"> + 2] == 0</span><span class="identifier">x67</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">buffer</span><span class="plain">[</span><span class="identifier">index</span><span class="plain"> + 3] == 0</span><span class="identifier">x53</span><span class="plain">)) {</span>
                    <span class="identifier">lastSig</span><span class="plain"> = </span><span class="identifier">seekPos</span><span class="plain"> + </span><span class="identifier">index</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>

            <span class="comment">Next place to read from is 256 bytes further on, but to catch</span>
            <span class="comment">sigs that span between these blocks, read the last four bytes again</span>
            <span class="identifier">seekPos</span><span class="plain"> += 256 - 4;</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lastSig</span><span class="plain"> == 0</span><span class="identifier">xFFFFFFFF</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, (</span><span class="reserved">long</span><span class="plain">) </span><span class="identifier">lastSig</span><span class="plain">, </span><span class="identifier">SEEK_SET</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sig</span><span class="plain"> != 0</span><span class="identifier">x4F676753</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">"OggS"</span></code> indicating an OGG file</span>

        <span class="comment">Check OGG version is zero</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int8</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">version</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">version</span><span class="plain"> != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Skip header Type</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, 1, </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int64</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">granulePosition</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="functiontext">BinaryFiles::swap_bytes64</span><span class="plain">(&amp;</span><span class="identifier">granulePosition</span><span class="plain">);</span>

        <span class="plain">*</span><span class="identifier">pDuration</span><span class="plain"> = (</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain">) ((</span><span class="identifier">granulePosition</span><span class="plain"> * 100) /</span>
                        <span class="plain">(</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">long</span><span class="plain"> </span><span class="reserved">long</span><span class="plain">) *</span><span class="identifier">pSampleRate</span><span class="plain">);</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="constant">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function SoundFiles::get_OggVorbis_duration appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. MIDI files. </b>At one time it was proposed that Inform 7 should allow a third sound file
format: MIDI. This provoked considerable debate in July 2007 and enough
doubts were raised that the implementation below was never in fact
officially used. It is preserved here in case we ever revive the issue.
</p>

<p class="inwebparagraph">Inform is not really able to decide this for itself, in any case, since
it can only usefully provide sound files which the virtual machines it
compiles for will allow. At present, the Glulx virtual machine does not
officially support MIDI, which makes the question moot.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">SoundFiles::get_MIDI_information</span><span class="plain">(</span><span class="reserved">FILE</span><span class="plain"> *</span><span class="identifier">pFile</span><span class="plain">, </span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pType</span><span class="plain">,</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">pNumTracks</span><span class="plain">) {</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sig</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">length</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">pulses</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">frames_per_second</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">subframes_per_frame</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">clocks_per_second</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">start_of_chunk_data</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">status</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">clocks</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sysex_length</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">non_midi_event_length</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">start_of_non_midi_data</span><span class="plain">;</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">non_midi_event</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment"><code class="display"><span class="extract">"RIFF"</span></code> indicating a RIFF file</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sig</span><span class="plain"> == 0</span><span class="identifier">x52494646</span><span class="plain">) {</span>
            <span class="comment">Skip the filesize and typeID</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, 8, </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

            <span class="comment">now read the real MIDI sig</span>
            <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="comment"><code class="display"><span class="extract">"MThd"</span></code> indicating a MIDI file</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sig</span><span class="plain"> != 0</span><span class="identifier">x4D546864</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read length of chunk</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">length</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Make sure we have enough data to read</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">length</span><span class="plain"> &lt; 6) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read the MIDI type: 0,1 or 2</span>
        <span class="comment">0 means one track containing up to 16 channels to make a single tune</span>
        <span class="comment">1 means one or more tracks, commonly each with a single channel, making up a single tune</span>
        <span class="comment">2 means one or more tracks, where each is a separate tune in it's own right</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int16</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">pType</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read the number of tracks</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int16</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">pNumTracks</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Read "Pulses Per Quarter Note" (PPQN)</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int16</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">pulses</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">if top bit set, then number of subframes per second can be deduced</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pulses</span><span class="plain"> &gt;= 0</span><span class="identifier">x8000</span><span class="plain">) {</span>
            <span class="comment">First byte is a negative number for the frames per second</span>
            <span class="comment">Second byte is the number of subframes in each frame</span>
            <span class="identifier">frames_per_second</span><span class="plain">    = (256 - (</span><span class="identifier">pulses</span><span class="plain"> &amp; 0</span><span class="identifier">xff</span><span class="plain">));</span>
            <span class="identifier">subframes_per_frame</span><span class="plain">  = (</span><span class="identifier">pulses</span><span class="plain"> &gt;&gt; 8);</span>
            <span class="identifier">clocks_per_second</span><span class="plain">    = </span><span class="identifier">frames_per_second</span><span class="plain"> * </span><span class="identifier">subframes_per_frame</span><span class="plain">;</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"frames_per_second   = %d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,   </span><span class="identifier">frames_per_second</span><span class="plain">);</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"subframes_per_frame = %d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">subframes_per_frame</span><span class="plain">);</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"clocks_per_second   = %d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,   </span><span class="identifier">clocks_per_second</span><span class="plain">);</span>

            <span class="comment">Number of pulses per quarter note unknown</span>
            <span class="identifier">pulses</span><span class="plain"> = 0;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="comment">unknown values</span>
            <span class="identifier">frames_per_second</span><span class="plain">    = 0;</span>
            <span class="identifier">subframes_per_frame</span><span class="plain">  = 0;</span>
            <span class="identifier">clocks_per_second</span><span class="plain">    = 0;</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"pulses per quarter note = %d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,   </span><span class="identifier">pulses</span><span class="plain">);</span>
        <span class="plain">}</span>

        <span class="comment">Skip any remaining bytes in the MThd chunk</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, (</span><span class="reserved">long</span><span class="plain">) (</span><span class="identifier">length</span><span class="plain"> - 6), </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

        <span class="comment">Keep reading chunks, looking for <code class="display"><span class="extract">"MTrk"</span></code></span>
        <span class="reserved">do</span><span class="plain"> {</span>
            <span class="comment">Read chunk signature and length</span>
            <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sig</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">feof</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">TRUE</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int32</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">length</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

            <span class="identifier">start_of_chunk_data</span><span class="plain"> = (</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain">) </span><span class="identifier">ftell</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">);</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sig</span><span class="plain"> == 0</span><span class="identifier">x4D54726B</span><span class="plain">) { </span>    <span class="comment"><code class="display"><span class="extract">"MTrk"</span></code></span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"track starts\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
                <span class="comment">Read each event, looking for information before the real tune starts, e.g., tempo</span>
                <span class="reserved">do</span><span class="plain"> {</span>
                    <span class="comment">Read the number of clocks since the previous event</span>
                    <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_variable_length_integer</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">clocks</span><span class="plain">))</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

                    <span class="comment">We bail out when the track starts</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">clocks</span><span class="plain"> &gt; 0) </span><span class="reserved">break</span><span class="plain">;</span>

                    <span class="comment">Read the MIDI Status byte</span>
                    <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int8</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">status</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

                    <span class="comment">Start or continuation of system exclusive data</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">status</span><span class="plain"> == 0</span><span class="identifier">xF0</span><span class="plain">) || (</span><span class="identifier">status</span><span class="plain"> == 0</span><span class="identifier">xF7</span><span class="plain">)) {</span>
                        <span class="comment">Read length of system exclusive event data</span>
                        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_variable_length_integer</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">sysex_length</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

                        <span class="comment">Skip sysex event</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, (</span><span class="reserved">long</span><span class="plain">) </span><span class="identifier">sysex_length</span><span class="plain">, </span><span class="identifier">SEEK_CUR</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">status</span><span class="plain"> == 0</span><span class="identifier">xFF</span><span class="plain">) { </span>    <span class="comment">Non-MIDI event</span>
                        <span class="comment">Read the Non-MIDI event type and length</span>
                        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_int8</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">non_midi_event</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
                        <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_variable_length_integer</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, &amp;</span><span class="identifier">non_midi_event_length</span><span class="plain">))</span>
                            <span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

                        <span class="identifier">start_of_non_midi_data</span><span class="plain"> = (</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain">) </span><span class="identifier">ftell</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">);</span>

                        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">non_midi_event</span><span class="plain">) {</span>
                            <span class="reserved">case</span><span class="plain"> 0</span><span class="identifier">x01</span><span class="plain">: </span>    <span class="comment">Comment text</span>
                            <span class="reserved">case</span><span class="plain"> 0</span><span class="identifier">x02</span><span class="plain">: </span>    <span class="comment">Copyright text</span>
                            <span class="reserved">case</span><span class="plain"> 0</span><span class="identifier">x03</span><span class="plain">: </span>    <span class="comment">Track name</span>
                            <span class="reserved">case</span><span class="plain"> 0</span><span class="identifier">x04</span><span class="plain">: { </span>    <span class="comment">Instrument name</span>
                                <span class="reserved">char</span><span class="plain"> </span><span class="identifier">text</span><span class="plain">[257];</span>
                                <span class="reserved">if</span><span class="plain"> (!</span><span class="functiontext">BinaryFiles::read_string</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, </span><span class="identifier">text</span><span class="plain">, </span><span class="identifier">non_midi_event_length</span><span class="plain">))</span>
                                    <span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
                                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%d: %s\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">non_midi_event</span><span class="plain">, </span><span class="identifier">text</span><span class="plain">);</span>
                                <span class="reserved">break</span><span class="plain">;</span>
                            <span class="plain">}</span>

                            <span class="reserved">case</span><span class="plain"> 0</span><span class="identifier">x51</span><span class="plain">: </span>    <span class="comment">Tempo change</span>
                            <span class="reserved">case</span><span class="plain"> 0</span><span class="identifier">x58</span><span class="plain">: </span>    <span class="comment">Time signature</span>
                            <span class="reserved">case</span><span class="plain"> 0</span><span class="identifier">x59</span><span class="plain">: </span>    <span class="comment">Key signature</span>
                                <span class="reserved">break</span><span class="plain">;</span>
                        <span class="plain">}</span>

                        <span class="comment">Skip non-midi event</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">,</span>
                            <span class="plain">(</span><span class="reserved">long</span><span class="plain">) (</span><span class="identifier">start_of_non_midi_data</span><span class="plain"> + </span><span class="identifier">non_midi_event_length</span><span class="plain">), </span><span class="identifier">SEEK_SET</span><span class="plain">) != 0)</span>
                            <span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="comment">Real MIDI data found: we've read all we can so bail out at this point</span>
                        <span class="reserved">break</span><span class="plain">;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="reserved">while</span><span class="plain"> (</span><span class="constant">TRUE</span><span class="plain">);</span>
            <span class="plain">}</span>

            <span class="comment">Seek to start of next chunk</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">fseek</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">, (</span><span class="reserved">long</span><span class="plain">) (</span><span class="identifier">start_of_chunk_data</span><span class="plain"> + </span><span class="identifier">length</span><span class="plain">), </span><span class="identifier">SEEK_SET</span><span class="plain">) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">FALSE</span><span class="plain">;</span>

            <span class="comment">Reached end of file</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">feof</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">TRUE</span><span class="plain">;</span>

            <span class="comment">Did we try to seek beyond the end of the file?</span>
            <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">position_in_file</span><span class="plain"> = (</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain">) </span><span class="identifier">ftell</span><span class="plain">(</span><span class="identifier">pFile</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">position_in_file</span><span class="plain"> &lt; (</span><span class="identifier">start_of_chunk_data</span><span class="plain"> + </span><span class="identifier">length</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="constant">TRUE</span><span class="plain">);</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="constant">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function SoundFiles::get_MIDI_information appears nowhere else.</p>

<!--End of weave: 337 lines from a web of 9279-->
	</body>
</html>

