[Weaver::] The Weaver.

To weave a portion of the code into instructions for TeX.

@h The Master Weaver.
Here's what has happened so far, on a weave run of Inweb: on any other
sort of run, of course, we would never be in this section of code. The web was
read completely into memory and fully parsed. A request was then made either
to swarm a mass of individual weaves, or to make just a single weave, with the
target in each case being identified by its range. A further decoding layer
then translated each range into rather more basic details of what to weave and
where to put the result: and so we arrive at the front door of the routine
|Weaver::weave| below.

=
int Weaver::weave(weave_order *wv) {
	web *W = wv->weave_web;

	Indexer::set_current_file(wv->weave_to);
	heterogeneous_tree *tree = WeaveTree::new_tree(wv);
	TEMPORARY_TEXT(banner);
	WRITE_TO(banner, "Weave of '%S' generated by Inweb", wv->booklet_title);
	tree_node *H = WeaveTree::head(tree, banner);
	DISCARD_TEXT(banner);
	tree_node *B = WeaveTree::body(tree);
	tree_node *T = WeaveTree::tail(tree, I"End of weave");
	Trees::make_child(H, tree->root);
	Trees::make_child(B, tree->root);
	Trees::make_child(T, tree->root);

	text_stream *cover_sheet = NULL;
	if ((Str::len(wv->cover_sheet_to_use) > 0) &&
		(Reader::web_has_one_section(W) == FALSE))
		cover_sheet = wv->cover_sheet_to_use;

	if (cover_sheet) @<Weave top half of cover sheet@>;
	int lines = Weaver::weave_inner(wv, tree, B);
	if (cover_sheet) @<Weave bottom half of cover sheet@>;

	WeaveTree::show(STDOUT, tree);

	text_stream TO_struct;
	text_stream *OUT = &TO_struct;
	if (STREAM_OPEN_TO_FILE(OUT, wv->weave_to, UTF8_ENC) == FALSE)
		Errors::fatal_with_file("unable to write woven file", wv->weave_to);
	Formats::render(OUT, tree);
	STREAM_CLOSE(OUT);
	Indexer::set_current_file(NULL);
	return lines;
}

@<Weave top half of cover sheet@> =
	TEMPORARY_TEXT(verbatim_content);
	if (!(Bibliographic::data_exists(W->md, I"Booklet Title")))
		Bibliographic::set_datum(W->md, I"Booklet Title", wv->booklet_title);
	Indexer::cover_sheet_maker(verbatim_content, W, cover_sheet, wv, WEAVE_FIRST_HALF);
	tree_node *V = WeaveTree::verbatim(tree, verbatim_content);
	Trees::make_child(V, B);
	DISCARD_TEXT(verbatim_content);

@<Weave bottom half of cover sheet@> =
	TEMPORARY_TEXT(verbatim_content);
	Indexer::cover_sheet_maker(verbatim_content, W, cover_sheet, wv, WEAVE_SECOND_HALF);
	tree_node *V = WeaveTree::verbatim(tree, verbatim_content);
	Trees::make_child(V, B);
	DISCARD_TEXT(verbatim_content);

@ =
int Weaver::weave_inner(weave_order *wv, heterogeneous_tree *tree, tree_node *body) {
	web *W = wv->weave_web;
	int lines_woven = 0;
	weaver_state state_at; weaver_state *state = &state_at;
	@<Start the weaver with a clean slate@>;
	chapter *C, *last_heading = NULL;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		if (C->md->imported == FALSE) {
			LOOP_OVER_LINKED_LIST(S, section, C->sections)
				if (Reader::range_within(S->md->sect_range, wv->weave_range)) {
					@<Weave any necessary chapter header@>;
					@<Weave any necessary section header@>;
					wv->current_footnote = NULL;
					LanguageMethods::begin_weave(S, wv);
					@<Weave this section@>;
					@<Weave any necessary section footer@>;
				}
		}
	@<Weave any necessary chapter footer@>;
	return lines_woven;
}

@<Weave any necessary chapter header@> =
	if (wv->theme_match == NULL) {
		if (last_heading != C) {
			@<Weave any necessary chapter footer@>;
			last_heading = C;
			tree_node *H = WeaveTree::chapter_header(tree, C);
			Trees::make_child(H, body);
		}
	}

@<Weave any necessary chapter footer@> =
	if (wv->theme_match == NULL) {
		if (last_heading != NULL) {
			tree_node *F = WeaveTree::chapter_footer(tree, last_heading);
			Trees::make_child(F, body);
		}
	}

@<Weave any necessary section header@> =
	if (wv->theme_match == NULL) {
		tree_node *H = WeaveTree::section_header(tree, S);
		Trees::make_child(H, body);
	}

@<Weave any necessary section footer@> =
	if (wv->theme_match == NULL) {
		tree_node *F = WeaveTree::section_footer(tree, S);
		Trees::make_child(F, body);
	}

@h The state.
We can now begin on a clean page, by initialising the state of the weaver:

@e REGULAR_MATERIAL from 1
@e MACRO_MATERIAL          /* when a macro is being defined... */
@e DEFINITION_MATERIAL     /* ...versus when an |@d| definition is being made */
@e CODE_MATERIAL           /* verbatim code */

=
typedef struct weaver_state {
	int kind_of_material; /* one of the enumerated |*_MATERIAL| constants above */
	int line_break_pending; /* insert a line break before the next woven line? */
	int next_heading_without_vertical_skip;
	int horizontal_rule_just_drawn;
	int in_run_of_definitions;
	struct section *last_extract_from;
	int substantive_comment;
} weaver_state;

@<Start the weaver with a clean slate@> =
	state->kind_of_material = REGULAR_MATERIAL;
	state->line_break_pending = FALSE;
	state->next_heading_without_vertical_skip = FALSE;
	state->horizontal_rule_just_drawn = FALSE;
	state->in_run_of_definitions = FALSE;
	state->last_extract_from = NULL;
	state->substantive_comment = FALSE;

@h Weaving a section.

@<Weave this section@> =
	paragraph *current_P = NULL;
	int toc_made = FALSE;
	for (source_line *LLL = S->first_line; LLL; LLL = LLL->next_line) {
		wv->current_weave_line = LLL;
		if (LLL->owning_paragraph == NULL)
			@<Largely ignore this extra-mural line@>
		else if (LLL->owning_paragraph != current_P) {
			if (toc_made == FALSE) {
				if (Str::len(S->sect_purpose) > 0) {
					tree_node *F = WeaveTree::purpose(tree, S->sect_purpose);
					Trees::make_child(F, body);
				}
				Weaver::weave_table_of_contents(tree, body, S);
				toc_made = TRUE;
			}
			current_P = LLL->owning_paragraph;
			if (Tags::tagged_with(current_P, wv->theme_match))
				@<Weave this paragraph@>;
		}
	}

@<Largely ignore this extra-mural line@> =
	if (LLL->category == INTERFACE_BODY_LCAT) {
		state->horizontal_rule_just_drawn = FALSE;
		continue;
	}
	if (LLL->category == PURPOSE_BODY_LCAT)  {
		continue;
	}
	if (LLL->category == DEFINITIONS_LCAT) {
		Weaver::weave_subheading(tree, wv, body, I"Definitions");
		state->next_heading_without_vertical_skip = TRUE;
		state->horizontal_rule_just_drawn = FALSE;
		continue;
	}
	if (LLL->category == BAR_LCAT) {
		state->kind_of_material = REGULAR_MATERIAL;
		state->next_heading_without_vertical_skip = TRUE;
		if (state->horizontal_rule_just_drawn == FALSE) {
			tree_node *B = WeaveTree::bar(tree);
			Trees::make_child(B, body);
		}
		continue;
	}
	if ((LLL->category == CHAPTER_HEADING_LCAT) ||
		(LLL->category == SECTION_HEADING_LCAT))
		continue;

@<Weave this paragraph@> =
	if (current_P->starts_on_new_page) Trees::make_child(WeaveTree::pagebreak(tree), body);
	source_line *L = LLL;
	if ((L->category != HEADING_START_LCAT) &&
		(L->category != PARAGRAPH_START_LCAT))
		Main::error_in_web(I"bad start to paragraph", L); /* should never happen */

	@<Deal with the marker for the start of a new paragraph, section or chapter@>;

	@<Weave any regular commentary text after the heading on the same line@>;
	L = L->next_line;
	for (; ((L) && (L->owning_paragraph == current_P)); L = L->next_line) {
		wv->current_weave_line = L;
		if (LanguageMethods::skip_in_weaving(S->sect_language, wv, L) == FALSE) {
			lines_woven++;
			@<Respond to any commands aimed at the weaver, and otherwise skip commands@>;
			@<Weave this line@>;
		}
	}
	L = NULL;
	@<End any currently weaving footnote text@>;
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		Weaver::change_material(tree, wv, body, mode_now, state->kind_of_material,
			TRUE, L?(L->plainer):FALSE);
	}
	Weaver::show_endnotes_on_previous_paragraph(tree, wv, body, current_P);

@h How paragraphs begin.

@<Deal with the marker for the start of a new paragraph, section or chapter@> =
	state->in_run_of_definitions = FALSE;
	LanguageMethods::reset_syntax_colouring(S->sect_language);
	if (wv->theme_match) @<Apply special rules for thematic extracts@>
	tree_node *H = WeaveTree::paragraph_heading(tree, current_P,
		state->next_heading_without_vertical_skip);
	Trees::make_child(H, body);
	state->next_heading_without_vertical_skip = FALSE;
	if (L->category == HEADING_START_LCAT) state->substantive_comment = TRUE;
	else state->substantive_comment = FALSE; 

@ If we are weaving a selection of extracted paragraphs, normal conventions
about breaking pages at chapters and sections fail to work. So:

@<Apply special rules for thematic extracts@> =
	text_stream *cap = Tags::retrieve_caption(L->owning_paragraph, wv->theme_match);
	if (Str::len(cap) > 0) {
		Weaver::weave_subheading(tree, wv, body, C->md->ch_title);
	} else if (state->last_extract_from != S) {
		TEMPORARY_TEXT(extr);
		WRITE_TO(extr, "From %S: %S", C->md->ch_title, S->md->sect_title);
		Weaver::weave_subheading(tree, wv, body, extr);
		DISCARD_TEXT(extr);
	}
	state->last_extract_from = S;
	state->substantive_comment = FALSE;

@ There's quite likely ordinary text on the line following the paragraph
 start indication, too, so we need to weave this out:

@<Weave any regular commentary text after the heading on the same line@> =
	if (Str::len(L->text_operand2) > 0) {
		TEMPORARY_TEXT(OUT);
		TEMPORARY_TEXT(matter);
		WRITE_TO(matter, "%S\n", L->text_operand2);
		Weaver::commentary_text(tree, wv, body, matter);
		DISCARD_TEXT(matter);
		state->substantive_comment = TRUE;
	}

@<Weave this line@> =
	if (L->category == BEGIN_CODE_LCAT) {
		state->line_break_pending = FALSE;
		LanguageMethods::reset_syntax_colouring(S->sect_language);
		continue;
	}

	if (L->category == END_EXTRACT_LCAT) {
		Weaver::change_material(tree, wv, body, state->kind_of_material, REGULAR_MATERIAL,
			TRUE, FALSE);
		state->kind_of_material = REGULAR_MATERIAL;
		continue;
	}

	TEMPORARY_TEXT(matter); Str::copy(matter, L->text);
	if (L->is_commentary) @<Weave verbatim matter in commentary style@>
	else {
		TEMPORARY_TEXT(OUT);
		@<Weave verbatim matter in code style@>;
		tree_node *V = WeaveTree::verbatim(tree, OUT);
		Trees::make_child(V, body);
		DISCARD_TEXT(OUT);
	}
	DISCARD_TEXT(matter);

@ And lastly we ignore commands, or act on them if they happen to be aimed
at us; but we don't weave them into the output, that's for sure.

@<Respond to any commands aimed at the weaver, and otherwise skip commands@> =
	if (L->category == COMMAND_LCAT) {
		if (L->command_code == PAGEBREAK_CMD)
			Trees::make_child(WeaveTree::pagebreak(tree), body);
		if (L->command_code == GRAMMAR_INDEX_CMD)
			Trees::make_child(WeaveTree::grammar_index(tree), body);
		if (L->command_code == FIGURE_CMD) @<Weave a figure@>;
		if (L->command_code == EMBED_CMD)
			Weaver::embed(tree, wv, body, L->text_operand, L->text_operand2);
		/* Otherwise assume it was a tangler command, and ignore it here */
		continue;
	}

@<Weave a figure@> =
	text_stream *figname = L->text_operand;
	match_results mr = Regexp::create_mr();
	if (Regexp::match(&mr, figname, L"(%d+)cm: (%c+)")) {
		if (S->md->using_syntax > V1_SYNTAX)
			Parser::wrong_version(S->md->using_syntax, L, "Figure: Xcm:...", V1_SYNTAX);
		Weaver::figure(tree, wv, body, mr.exp[1], Str::atoi(mr.exp[0], 0), -1);
	} else if (Regexp::match(&mr, figname, L"(%c+) width (%d+)cm")) {
		if (S->md->using_syntax < V2_SYNTAX)
			Parser::wrong_version(S->md->using_syntax, L, "F width Xcm", V2_SYNTAX);
		Weaver::figure(tree, wv, body, mr.exp[0], Str::atoi(mr.exp[1], 0), -1);
	} else if (Regexp::match(&mr, figname, L"(%c+) height (%d+)cm")) {
		if (S->md->using_syntax < V2_SYNTAX)
			Parser::wrong_version(S->md->using_syntax, L, "F height Xcm", V2_SYNTAX);
		Weaver::figure(tree, wv, body, mr.exp[0], -1, Str::atoi(mr.exp[1], 0));
	} else {
		Weaver::figure(tree, wv, body, figname, -1, -1);
	}
	Regexp::dispose_of(&mr);	

@h Commentary matter.
Typographically this is a fairly simple business: it's almost the case that
we only have to transcribe it. But not quite!

@<Weave verbatim matter in commentary style@> =
	@<Weave displayed source in its own special style@>;
	@<Weave a blank line as a thin vertical skip and paragraph break@>;
	@<Weave bracketed list indications at start of line into indentation@>;
	@<Weave tabbed code material as a new indented paragraph@>;
	@<Weave footnotes@>;
	state->substantive_comment = TRUE;
	WRITE_TO(matter, "\n");
	Weaver::commentary_text(tree, wv, body, matter);
	continue;

@ Displayed source is the material marked with |>>| arrows in column 1.

@<Weave displayed source in its own special style@> =
	if (L->category == SOURCE_DISPLAY_LCAT) {
		Trees::make_child(WeaveTree::display_line(tree, L->text_operand), body);
		continue;
	}

@ Our style is to use paragraphs without initial-line indentation, so we
add a vertical skip between them to show the division more clearly.

@<Weave a blank line as a thin vertical skip and paragraph break@> =
	if (Regexp::string_is_white_space(matter)) {
		if ((L->next_line) && (L->next_line->category == COMMENT_BODY_LCAT) &&
			(state->substantive_comment)) {
			match_results mr = Regexp::create_mr();
			if ((state->kind_of_material != CODE_MATERIAL) ||
				(Regexp::match(&mr, matter, L"\t|(%c*)|(%c*?)"))) {
				@<End any currently weaving footnote text@>;
				Trees::make_child(WeaveTree::vskip(tree, TRUE), body);
			}
			Regexp::dispose_of(&mr);	
		}
		continue;
	}

@ Here our extension is simply to provide a tidier way to use TeX's standard
|\item| and |\itemitem| macros for indented list items.

@<Weave bracketed list indications at start of line into indentation@> =
	match_results mr = Regexp::create_mr();
	if (Regexp::match(&mr, matter, L"%(...%) (%c*)")) { /* continue single */
		Weaver::change_material(tree, wv, body, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment, FALSE);
		state->kind_of_material = REGULAR_MATERIAL;
		Trees::make_child(WeaveTree::weave_item_node(tree, 1, I""), body);
		Str::copy(matter, mr.exp[0]);
	} else if (Regexp::match(&mr, matter, L"%(-...%) (%c*)")) { /* continue double */
		Weaver::change_material(tree, wv, body, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment, FALSE);
		state->kind_of_material = REGULAR_MATERIAL;
		Trees::make_child(WeaveTree::weave_item_node(tree, 2, I""), body);
		Str::copy(matter, mr.exp[0]);
	} else if (Regexp::match(&mr, matter, L"%((%i+)%) (%c*)")) { /* begin single */
		Weaver::change_material(tree, wv, body, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment, FALSE);
		state->kind_of_material = REGULAR_MATERIAL;
		Trees::make_child(WeaveTree::weave_item_node(tree, 1, mr.exp[0]), body);
		Str::copy(matter, mr.exp[1]);
	} else if (Regexp::match(&mr, matter, L"%(-(%i+)%) (%c*)")) { /* begin double */
		Weaver::change_material(tree, wv, body, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment, FALSE);
		state->kind_of_material = REGULAR_MATERIAL;
		Trees::make_child(WeaveTree::weave_item_node(tree, 2, mr.exp[0]), body);
		Str::copy(matter, mr.exp[1]);
	}
	Regexp::dispose_of(&mr);

@ Finally, matter encased in vertical strokes one tab stop in from column 1
in the source is set indented in code style.

@<Weave tabbed code material as a new indented paragraph@> =
	match_results mr = Regexp::create_mr();
	if (Regexp::match(&mr, matter, L"\t|(%c*)|(%c*?)")) {
		TEMPORARY_TEXT(OUT);
		if (state->kind_of_material != CODE_MATERIAL) {
			Weaver::change_material(tree, wv, body, state->kind_of_material, CODE_MATERIAL,
				TRUE, L->plainer);
			state->kind_of_material = CODE_MATERIAL;
		}
		TEMPORARY_TEXT(original);
 		Str::copy(original, mr.exp[0]);
		Str::copy(matter, mr.exp[1]);
		TEMPORARY_TEXT(colouring);
		for (int i=0; i<Str::len(original); i++) PUT_TO(colouring, PLAIN_COLOUR);
		Formats::source_code(OUT, wv, 1, I"", original, colouring, I"", TRUE, TRUE,
			FALSE, L->enable_hyperlinks);
		Formats::text(OUT, wv, matter);
		DISCARD_TEXT(colouring);
		DISCARD_TEXT(original);
		tree_node *V = WeaveTree::verbatim(tree, OUT);
		Trees::make_child(V, body);
		DISCARD_TEXT(OUT);
		continue;
	} else if (state->kind_of_material != REGULAR_MATERIAL) {
		Weaver::change_material(tree, wv, body, state->kind_of_material, REGULAR_MATERIAL,
			TRUE, FALSE);
		state->kind_of_material = REGULAR_MATERIAL;
	}
	Regexp::dispose_of(&mr);

@<Weave footnotes@> =
	if (L->category == FOOTNOTE_TEXT_LCAT) {
		@<End any currently weaving footnote text@>;
		footnote *F = L->footnote_text;
		wv->current_footnote = F;
		TEMPORARY_TEXT(OUT);
		Formats::begin_footnote_text(OUT, wv, F->cue_text);
		tree_node *V = WeaveTree::verbatim(tree, OUT);
		Trees::make_child(V, body);
		DISCARD_TEXT(OUT);
		if (F->cued_already == FALSE) Main::error_in_web(I"footnote never cued", L);
	}

@<End any currently weaving footnote text@> =
	if (wv->current_footnote) {
		TEMPORARY_TEXT(cue);
		WRITE_TO(cue, "%d", wv->current_footnote->footnote_text_number);
		TEMPORARY_TEXT(OUT);
		Formats::end_footnote_text(OUT, wv, cue);
		tree_node *V = WeaveTree::verbatim(tree, OUT);
		Trees::make_child(V, body);
		DISCARD_TEXT(OUT);
		DISCARD_TEXT(cue);
		wv->current_footnote = NULL;
	}	

@h Code-like matter.
Even though Inweb's approach, unlike |CWEB|'s, is to respect the layout
of the original, this is still quite typographically complex: commentary
and macro usage is rendered differently.

@<Weave verbatim matter in code style@> =
	@<Enter beginlines/endlines mode if necessary@>;
	@<Weave a blank line as a thin vertical skip@>;

	int tab_stops_of_indentation = 0;
	@<Convert leading space in line matter to a number of tab stops@>;

	TEMPORARY_TEXT(prefatory);
	TEMPORARY_TEXT(concluding_comment);
	@<Extract any comment matter ending the line to be set in italic@>;
	@<Give constant definition lines slightly fancier openings@>;

	if (LanguageMethods::weave_code_line(OUT, S->sect_language, wv,
		W, C, S, L, matter, concluding_comment)) goto ClumsyLabel;

	TEMPORARY_TEXT(colouring);
	LanguageMethods::syntax_colour(OUT, S->sect_language, wv, L, matter, colouring);

	int found = 0;
	@<Find macro usages and adjust syntax colouring accordingly@>;
	if (Str::len(prefatory) > 0) {
		state->in_run_of_definitions = TRUE;
	} else {
		if (state->in_run_of_definitions) Formats::after_definitions(OUT, wv);
		state->in_run_of_definitions = FALSE;
	}

	Formats::source_code(OUT, wv, tab_stops_of_indentation, prefatory,
		matter, colouring, concluding_comment, (found == 0)?TRUE:FALSE, TRUE,
		TRUE, L->enable_hyperlinks);
	DISCARD_TEXT(colouring);
	DISCARD_TEXT(concluding_comment);
	DISCARD_TEXT(prefatory);
	
	ClumsyLabel: ;

@ Code is typeset between the |\beginlines| and |\endlines| macros in TeX,
hence the name of the following paragraph:

@<Enter beginlines/endlines mode if necessary@> =
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != CODE_MATERIAL) {
		if (L->category == MACRO_DEFINITION_LCAT)
			state->kind_of_material = MACRO_MATERIAL;
		else if ((L->category == BEGIN_DEFINITION_LCAT) ||
				(L->category == CONT_DEFINITION_LCAT))
			state->kind_of_material = DEFINITION_MATERIAL;
		else if ((state->kind_of_material == DEFINITION_MATERIAL) &&
			((L->category == CODE_BODY_LCAT) || (L->category == COMMENT_BODY_LCAT)) &&
			(Str::len(L->text) == 0))
			state->kind_of_material = DEFINITION_MATERIAL;
		else
			state->kind_of_material = CODE_MATERIAL;
		Weaver::change_material(tree, wv, body, mode_now, state->kind_of_material,
			state->substantive_comment, L->plainer);
		state->line_break_pending = FALSE;
	}

@ A blank line is typeset as a thin vertical skip (no TeX paragraph break
is needed):

@<Weave a blank line as a thin vertical skip@> =
	if (state->line_break_pending) {
		Trees::make_child(WeaveTree::vskip(tree, FALSE), body);
		state->line_break_pending = FALSE;
	}
	if (Regexp::string_is_white_space(matter)) {
		state->line_break_pending = TRUE;
		goto ClumsyLabel;
	}

@ Examine the white space at the start of the code line, and count the
number of tab steps of indentation, rating 1 tab = 4 spaces:

@<Convert leading space in line matter to a number of tab stops@> =
	int spaces_in = 0;
	while (Characters::is_space_or_tab(Str::get_first_char(matter))) {
		if (Str::get_first_char(matter) == '\t') {
			spaces_in = 0;
			tab_stops_of_indentation++;
		} else {
			spaces_in++;
			if (spaces_in == 4) {
				tab_stops_of_indentation++;
				spaces_in = 0;
			}
		}
		Str::delete_first_character(matter);
	}
	if (spaces_in > 0) {
		TEMPORARY_TEXT(respaced);
		while (spaces_in > 0) { PUT_TO(respaced, ' '); spaces_in--; }
		WRITE_TO(respaced, "%S", matter);
		Str::clear(matter);
		Str::copy(matter, respaced);
		DISCARD_TEXT(respaced);
	}

@ Comments which run to the end of a line are set in italic type. If the
only item on their lines, they are presented at the code tab stop;
otherwise, they are set flush right.

@<Extract any comment matter ending the line to be set in italic@> =
	TEMPORARY_TEXT(part_before_comment);
	TEMPORARY_TEXT(part_within_comment);
	programming_language *pl = S->sect_language;
	if (L->category == TEXT_EXTRACT_LCAT) pl = L->colour_as;
	if ((pl) && (LanguageMethods::parse_comment(pl,
		matter, part_before_comment, part_within_comment))) {
		Str::copy(matter, part_before_comment);
		Str::copy(concluding_comment, part_within_comment);
	}
	DISCARD_TEXT(part_before_comment);
	DISCARD_TEXT(part_within_comment);

@ Set the |@d| definition escape very slightly more fancily:

@<Give constant definition lines slightly fancier openings@> =
	if (L->category == BEGIN_DEFINITION_LCAT) {
		match_results mr = Regexp::create_mr();
		if ((Regexp::match(&mr, matter, L"@d (%c*)")) ||
			(Regexp::match(&mr, matter, L"@define (%c*)"))) {
			Str::copy(prefatory, I"define");
			Str::copy(matter, mr.exp[0]);
		} else if ((Regexp::match(&mr, matter, L"@e (%c*)")) ||
			(Regexp::match(&mr, matter, L"@enum (%c*)"))) {
			Str::copy(prefatory, I"enum");
			Str::copy(matter, mr.exp[0]);
		}
		Regexp::dispose_of(&mr);
	}

@<Find macro usages and adjust syntax colouring accordingly@> =
	match_results mr = Regexp::create_mr();
	while (Regexp::match(&mr, matter, L"(%c*?)%@%<(%c*?)%@%>(%c*)")) {
		para_macro *pmac = Macros::find_by_name(mr.exp[1], S);
		if (pmac) {
			Str::copy(matter, mr.exp[2]);
			Formats::source_code(OUT, wv, tab_stops_of_indentation, prefatory,
				mr.exp[0], colouring, concluding_comment, (found == 0)?TRUE:FALSE,
				FALSE, TRUE, L->enable_hyperlinks);
			LanguageMethods::reset_syntax_colouring(S->sect_language);
			found++;
			int defn = FALSE;
			if (pmac) defn = (L->owning_paragraph == pmac->defining_paragraph)?TRUE:FALSE;
			if (defn) state->in_run_of_definitions = FALSE;
			if (pmac) Formats::para_macro(OUT, wv, pmac, defn);
			if (defn) Str::clear(matter);
			TEMPORARY_TEXT(temp);
			int L = Str::len(colouring);
			for (int i = L - Str::len(matter); i < L; i++)
				PUT_TO(temp, Str::get_at(colouring, i));
			Str::copy(colouring, temp);
			DISCARD_TEXT(temp);
		} else break;
	}
	Regexp::dispose_of(&mr);


@h Endnotes.
The endnotes describe function calls from far away, or unexpected
structure usage, or how |CWEB|-style code substitutions were made.

=
void Weaver::show_endnotes_on_previous_paragraph(heterogeneous_tree *tree,
	weave_order *wv, tree_node *body, paragraph *P) {
	Tags::show_endnote_on_ifdefs(tree, wv, body, P);
	if (P->defines_macro)
		@<Show endnote on where paragraph macro is used@>;
	language_function *fn;
	LOOP_OVER_LINKED_LIST(fn, language_function, P->functions)
		@<Show endnote on where this function is used@>;
	language_type *st;
	LOOP_OVER_LINKED_LIST(st, language_type, P->structures)
		@<Show endnote on where this language type is accessed@>;
}

@<Show endnote on where paragraph macro is used@> =
	TEMPORARY_TEXT(OUT);
	Formats::text(OUT, wv, I"This code is ");
	int ct = 0;
	macro_usage *mu;
	LOOP_OVER_LINKED_LIST(mu, macro_usage, P->defines_macro->macro_usages)
		ct++;
	if (ct == 1) Formats::text(OUT, wv, I"never used");
	else {
		int k = 0, used_flag = FALSE;
		LOOP_OVER_LINKED_LIST(mu, macro_usage, P->defines_macro->macro_usages)
			if (P != mu->used_in_paragraph) {
				if (used_flag) {
					if (k < ct-1) Formats::text(OUT, wv, I", ");
					else Formats::text(OUT, wv, I" and ");
				} else {
					Formats::text(OUT, wv, I"used in ");
				}
				Formats::locale(OUT, wv, mu->used_in_paragraph, NULL);
				used_flag = TRUE; k++;
				switch (mu->multiplicity) {
					case 1: break;
					case 2: Formats::text(OUT, wv, I" (twice)"); break;
					case 3: Formats::text(OUT, wv, I" (three times)"); break;
					case 4: Formats::text(OUT, wv, I" (four times)"); break;
					case 5: Formats::text(OUT, wv, I" (five times)"); break;
					default: {
						TEMPORARY_TEXT(mt);
						WRITE_TO(mt, " (%d times)", mu->multiplicity);
						Formats::text(OUT, wv, mt);
						DISCARD_TEXT(mt);
						break;
					}
				}
			}
	}
	Formats::text(OUT, wv, I".");
	Weaver::show_endnote(tree, wv, body, OUT);
	DISCARD_TEXT(OUT);

@<Show endnote on where this function is used@> =
	if (fn->usage_described == FALSE) {
		TEMPORARY_TEXT(OUT);
		Weaver::show_function_usage(OUT, wv, P, fn, FALSE);
		Weaver::show_endnote(tree, wv, body, OUT);
		DISCARD_TEXT(OUT);
	}

@<Show endnote on where this language type is accessed@> =
	TEMPORARY_TEXT(OUT);
	Formats::text(OUT, wv, I"The structure ");
	Formats::text(OUT, wv, st->structure_name);

	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	structure_element *elt;
	LOOP_OVER_LINKED_LIST(elt, structure_element, st->elements) {
		hash_table_entry *hte =
			Analyser::find_hash_entry_for_section(elt->element_created_at->owning_section,
				elt->element_name, FALSE);
		if (hte) {
			hash_table_entry_usage *hteu;
			LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
				if (hteu->form_of_usage & ELEMENT_ACCESS_USAGE)
					hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
		}
	}

	int usage_count = 0, external = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag) {
			usage_count++;
			if (S != P->under_section) external++;
		}
	if (external == 0) Formats::text(OUT, wv, I" is private to this section");
	else {
		Formats::text(OUT, wv, I" is accessed in ");
		int c = 0;
		LOOP_OVER(S, section)
			if ((S->scratch_flag) && (S != P->under_section)) {
				if (c++ > 0) Formats::text(OUT, wv, I", ");
				Formats::text(OUT, wv, S->md->sect_range);
			}
		if (P->under_section->scratch_flag) Formats::text(OUT, wv, I" and here");
	}
	Formats::text(OUT, wv, I".");
	Weaver::show_endnote(tree, wv, body, OUT);
	DISCARD_TEXT(OUT);

@ =
void Weaver::show_endnote(heterogeneous_tree *tree,
	weave_order *wv, tree_node *body, text_stream *text) {
	tree_node *E = WeaveTree::endnote(tree, text);
	Trees::make_child(E, body);
}

@ =
void Weaver::show_function_usage(OUTPUT_STREAM, weave_order *wv, paragraph *P,
	language_function *fn, int as_list) {
	fn->usage_described = TRUE;
	hash_table_entry *hte =
		Analyser::find_hash_entry_for_section(fn->function_header_at->owning_section,
			fn->function_name, FALSE);
	if (as_list == FALSE) {
		Formats::text(OUT, wv, I"The function ");
		Formats::text(OUT, wv, fn->function_name);
	}
	int used_flag = FALSE;
	hash_table_entry_usage *hteu = NULL;
	section *last_cited_in = NULL;
	int count_under = 0;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if ((P != hteu->usage_recorded_at) &&
			(P->under_section == hteu->usage_recorded_at->under_section))
			@<Cite usage of function here@>;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if (P->under_section != hteu->usage_recorded_at->under_section)
			@<Cite usage of function here@>;
	if (used_flag == FALSE) {
		if (as_list == FALSE) {
			Formats::text(OUT, wv, I" appears nowhere else");
		} else {
			Formats::text(OUT, wv, I"none");
		}
	}
	if (as_list == FALSE) {
		if ((last_cited_in != P->under_section) && (last_cited_in))
			Formats::text(OUT, wv, I")");
		Formats::text(OUT, wv, I".");
	}
}

@<Cite usage of function here@> =
	if (as_list == FALSE) {
		if (used_flag == FALSE) Formats::text(OUT, wv, I" is used in ");
	}
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (as_list == FALSE) {
				if (last_cited_in != P->under_section) Formats::text(OUT, wv, I"), ");
				else Formats::text(OUT, wv, I", ");
			} else {
				if (last_cited_in != P->under_section) WRITE("<br>");
				else Formats::text(OUT, wv, I", ");
			}
		}
		Formats::text(OUT, wv, hteu->usage_recorded_at->under_section->md->sect_title);
		if (as_list == FALSE) Formats::text(OUT, wv, I" (");
		else WRITE(" - ");
	}
	if (count_under++ > 0) Formats::text(OUT, wv, I", ");
	Formats::locale(OUT, wv, hteu->usage_recorded_at, NULL);
	last_cited_in = hteu->usage_recorded_at->under_section;

@h Non-paragraph subheadings.

=
void Weaver::weave_subheading(heterogeneous_tree *tree, weave_order *wv,
	tree_node *body, text_stream *text) {
	tree_node *D = WeaveTree::subheading(tree, text);
	Trees::make_child(D, body);
}

void Weaver::change_material(heterogeneous_tree *tree, weave_order *wv,
	tree_node *body, int old_material, int new_material, int content, int plainly) {
	tree_node *D = WeaveTree::chm(tree, old_material, new_material, content, plainly);
	Trees::make_child(D, body);
}

void Weaver::figure(heterogeneous_tree *tree, weave_order *wv,
	tree_node *body, text_stream *figname, int w, int h) {
	tree_node *F = WeaveTree::figure(tree, figname, w, h);
	Trees::make_child(F, body);
}

void Weaver::embed(heterogeneous_tree *tree, weave_order *wv,
	tree_node *body, text_stream *service, text_stream *ID) {
	tree_node *F = WeaveTree::embed(tree, service, ID);
	Trees::make_child(F, body);
}

void Weaver::commentary_text(heterogeneous_tree *tree, weave_order *wv,
	tree_node *body, text_stream *matter) {
	TEMPORARY_TEXT(OUT);
	Formats::text(OUT, wv, matter);
	tree_node *V = WeaveTree::verbatim(tree, OUT);
	Trees::make_child(V, body);
	DISCARD_TEXT(OUT);
}

@h Section tables of contents.
These appear at the top of each woven section, and give links to the paragraphs
marked as |@h| headings.

=
int Weaver::weave_table_of_contents(heterogeneous_tree *tree,
	tree_node *body, section *S) {
	int noteworthy = 0;
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE)))
			noteworthy++;
	if (noteworthy == 0) return FALSE;

	tree_node *TOC = WeaveTree::table_of_contents(tree, S->md->sect_range);
	Trees::make_child(TOC, body);
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE))) {
			TEMPORARY_TEXT(loc);
			WRITE_TO(loc, "%S%S", P->ornament, P->paragraph_number);
			Trees::make_child(
				WeaveTree::contents_line(tree, loc,
					P->first_line_in_paragraph->text_operand, P), TOC);
			DISCARD_TEXT(loc);
		}
	return TRUE;
}

